## 1.1 pimpl介绍

```C++
/*
<1>pimpl主要是为了避免暴露实现细节。
<2>以指针包含p_impl资源，将变量封装以保证安全，
<3>pimpl是Qt::Ui常用的做法，一般设计成内部类就好了，和外部类可以放在一起实现。
*/
```

## 1.2 pimpl方案

### 1.2.1 嵌套命名空间法

```C++
/*头文件 module.h*/
namespace my_module {
    class Module {
        /*前向声明*/
        struct Impl;
        Impl *impl_;
    };
}

/* 要点就是命名空间要一致*/
/*detail 实现层*/
/*module.cpp*/
namespace my_module {
    struct Module::Impl {
    };
}
```

  

### 1.2.2 匿名命名空间与void*

```C++
/*头文件 module.h*/
class Module {
    Module();
    ~Module();

    void *impl_;
};

/*detail 实现层*/
/*module.cpp*/
#include "module.h"

namespace {
    struct Impl {
        /*一些数据*/
    };
}

Module::Module() : impl_(new Impl) {
}

Module::~Module() { delete static_cast<Impl *>(impl_); }
```

  

### 1.2.3 配合using的命名空间隔离

```C++
/* 头文件（public.h）*/
namespace my_module {
    class DataProcessor {
    private:
        using Impl = detail::DataProcessorImpl; // 类型别名（带命名空间）
        std::unique_ptr<Impl> pimpl_;
    };
} /* namespace my_module*/

/* 内部头文件（detail/impl.h）*/
namespace my_module::detail {
    struct DataProcessorImpl {
        // 实现命名空间
        int buffer_size;
    };
} /* namespace my_module::detail*/

/* 实现文件（data_processor.cpp）*/
#include "detail/impl.h"

namespace my_module {
    DataProcessor::DataProcessor()
        : pimpl_(std::make_unique<detail::DataProcessorImpl>()) {
    }
}
```

### 1.2.4 带模板优化的隔离impl

```c++
/* 编译单元内的类型安全封装（.cpp）*/
namespace {
    template<typename T>
    struct OpaquePtr {
        void *ptr;

        T *operator->() const {
            return static_cast<T *>(ptr);
        }
    };

    struct Impl {
    };
}

/* 模板避免了手动cast的长书写麻烦,适合多次使用impl的场景 */
MyClass::MyClass() : impl_(new Impl) {
}

void MyClass::PublicMethod() {
    OpaquePtr<Impl> test{impl_};
    test->client.DoSomething(); /* 直接调用，无额外开销 */
}
```

  

### 1.2.5 模板基类的impl

```C++
/* 通用Pimpl基类（header-only）*/
template<typename Derived>
class PimplBase {
protected:
    struct Impl {
        virtual ~Impl() = default;
    };

    std::unique_ptr<Impl> pimpl_;
    Derived& derived() { return static_cast<Derived &>(*this); }
};

/* 具体类实现*/
class Database : private PimplBase<Database> {
private:
    struct Impl : PimplBase<Database>::Impl {
        /* 继承通用Impl*/
        sqlite3 *db;
    };

    friend class PimplBase<Database>;
};
```

  

### 1.2.6 代理类impl与->穿透

```C++
/* 当嵌套的代理类都重载了->，可以在最外层直接用->访问到最内层的数据。*/
/* 头文件（仅暴露接口，无类型信息）PhysicsWorld.h*/
class PhysicsWorld {
public:
    auto operator->() const noexcept; /* 重载->，返回代理类*/
    /* auto 作为返回值是C++14引入的，
    C++11需要配合后置类型->decltype(表达式) */
private:
    void *impl_ = nullptr; /* 不透明指针*/
};


/*实现+定义pimpl文件 PhysicsWorld.cpp*/
namespace {/* 编译单元本地作用域*/
    struct Impl {/* 隐藏的具体实现*/
        float simulation_time = 0.5f;
    };

    /* 代理类：重载->操作符的核心,这里实际上可以做成模板*/
    class Proxy {
        void *ptr_;

    public:
        explicit Proxy(void *ptr) noexcept : ptr_(ptr) { }

        /*支持箭头操作（如->frame_count）*/
        auto operator->() const {
            return static_cast<Impl *>(ptr_);
        }
    };
} /* namespace*/
/*接口实现*/
PhysicsWorld::PhysicsWorld() {
    impl_ = new Impl{};
}

PhysicsWorld::~PhysicsWorld() {
    delete static_cast<Impl *>(impl_);
}

auto PhysicsWorld::operator->() const noexcept {
    return Proxy{impl_};
}

#include <iostream>

int main() {
    PhysicsWorld a;
    std::cout << a->simulation_time; /*成功打印0.5*/
}
```

  

### 1.2.7 带静态成员函数impl

```C++
/*实现文件 PhysicsWorld.cpp*/
namespace {
    struct Impl {
        static void SimulateImpl(void *self) {
            /* 静态成员函数*/
            auto *impl = static_cast<Impl *>(self);
            /* 对impl操作 */
        }
    };
}

void PhysicsWorld::Simulate() {
    Impl::SimulateImpl(impl_); /* 正确：静态函数直接调用*/
}
```

  

### 1.2.8 成员指针代替函数的impl

```C++
/* 实现文件 */
namespace {
    struct Impl {
        using SimulateFunc = void(
        )(void); /* 函数指针类型*/
        SimulateFunc simulate; /* 成员函数指针（非静态）*/
        Impl() : simulate(&SimulateImpl) {
        } /* 初始化函数指针*/
    private:
        static void SimulateImpl(void *self) {
            auto *impl = static_cast<Impl *>(self);
            /* 操作impl */
        }
    };
}

void PhysicsWorld::Simulate() {
    auto *impl = static_cast<Impl *>(impl_);
    impl->simulate(impl_); /*✅ 函数指针调用，无符号导出*/
}
```