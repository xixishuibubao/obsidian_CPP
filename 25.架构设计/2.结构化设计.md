### 一、架构设计核心原则（应对非完全模块化）

1. **接口与实现物理分离**
    
    1. 模块对外仅暴露`.h`接口文件，实现细节封装在`.cpp`和`detail/`目录
        
    2. 强制使用**前向声明+Pimpl**隐藏依赖（如`class OtherModule;`而非`#include "other_module.h"`）
        

  

2. **分层依赖规则（单向依赖）**
    
    ```Plain
    应用层（main） → 业务模块 → 核心库 → 基础组件  
    ▲                ▲          ▲          ▲  
    │                │          │          │  
    └────────────────┴──────────┴──────────┴───────────  
    禁止反向依赖（如核心库不能依赖业务模块）
    ```
    

  

3. **依赖最小化策略**
    
    1. 模块间仅通过**抽象接口**（纯虚类）通信，避免直接依赖具体实现
        
    2. 使用**编译防火墙**（Pimpl+私有继承）隔离实现变更
        

  

  

### 二、模块化架构的4层实现方案

#### 1. 模块接口层（public/）

```C++
// 模块A接口（public/module_a.h）
#pragma once
#include <memory>  // 仅包含必要标准头

namespace module_a {
class Controller {
public:
    virtual void ProcessEvent(int event_id) = 0;
    virtual ~Controller() = default;
};

std::unique_ptr<Controller> CreateController();  // 工厂函数，隐藏依赖
}  // namespace module_a
```

  

#### 2. 模块实现层（src/module_a/）

```C++
// 实现文件（src/module_a/controller.cpp）
#include "public/module_a.h"
#include "detail/module_b_client.h"  // 内部依赖，不暴露给外部

namespace module_a {
class ControllerImpl : public Controller {
private:
    module_b::Client client_;  // 不可避免的内部依赖
public:
    void ProcessEvent(int event_id override {
        client_.Send(event_id);  // 依赖模块B的具体实现
    }
};

std::unique_ptr<Controller> CreateController() {
    return std::make_unique<ControllerImpl>();
}
}  // namespace module_a
```

  

#### 3. 内部依赖隔离层（detail/）

```C++
// 模块B客户端（detail/module_b_client.h）
#pragma once
#include <module_b/public/client.h>  // 仅在实现层包含

namespace module_a::detail {
class ClientWrapper {
public:
    void Send(int event_id) {
        module_b::Client::Instance().Send(event_id);
    }
};
}  // namespace module_a::detail
```

  

#### 4. 依赖治理层（build/）

```CMake
# CMakeLists.txt 依赖规则
add_library(module_a PUBLIC public/module_a.h)
target_include_directories(module_a PRIVATE src/module_a/detail)
target_link_libraries(module_a PRIVATE module_b)  // 显式依赖声明
```

  

  

### 三、处理不可避免依赖的5大技术方案

#### 1. 接口隔离（Interface Isolation）

```C++
// 模块B提供的抽象接口（module_b/public/i_event_sink.h）
namespace module_b {
class IEventSink {
public:
    virtual void OnEvent(int event_id) = 0;
    virtual ~IEventSink() = default;
};
}  // namespace module_b

// 模块A实现接口（不依赖模块B具体实现）
class ModuleAHandler : public module_b::IEventSink {
public:
    void OnEvent(int event_id) override { /* 处理逻辑 */ }
};
```

  

#### 2. 依赖注入（Dependency Injection）

```C++
// 模块A构造函数注入依赖
class ModuleA {
private:
    std::shared_ptr<module_b::IEventSink> sink_;
public:
    ModuleA(std::shared_ptr<module_b::IEventSink> sink) : sink_(sink) {}
    void DoWork() { sink_->OnEvent(123); }
};

// 入口处绑定具体实现
auto sink = std::make_shared<module_b::EventSink>();
auto a = ModuleA(sink);
```

  

#### 3. 编译期依赖隔离（Pimpl+私有继承）

```C++
// 模块A头文件（仅前向声明）
namespace module_b { class Client; }

class ModuleA {
private:
    struct Impl;  // 隐藏依赖
    std::unique_ptr<Impl> pimpl_;
public:
    ModuleA();
    ~ModuleA();
};

// 实现文件（包含模块B头文件）
#include "module_b/client.h"
struct ModuleA::Impl {
    module_b::Client client;
};
```

  

#### 4. 事件总线解耦（全局事件机制）

```C++
// 事件总线（全局单例）
class EventBus {
public:
    template <typename T>
    void RegisterHandler(std::function<void(T)> handler) {
        handlers_[typeid(T)] = [handler](const Event& e) {
            handler(*static_cast<const T*>(&e));
        };
    }
};

// 模块A发布事件
event_bus.Publish(ModuleAEvent{456});

// 模块B订阅事件（无需直接依赖A）
event_bus.RegisterHandler<ModuleAEvent>([](auto e) { /* 处理 */ });
```

  

#### 5. 版本化依赖（Semantic Versioning）

```CMake
# 模块B CMake 导出
add_library(module_b SHARED src/module_b.cpp)
set_target_properties(module_b PROPERTIES
    VERSION 1.2.0
    SOVERSION 1
)

# 模块A链接指定版本
find_package(module_b 1.2 REQUIRED)
target_link_libraries(module_a PUBLIC module_b::module_b)
```

  

  

### 四、依赖治理工具链（工业级落地）

#### 1. 静态依赖分析（Clang-Tidy）

```YAML
# .clang-tidy 禁止反向依赖
Checks: '-*,readability-including-field-in-constructor,modernize-*'
HeaderGuard:
  CheckAttributes: true
  HeaderFileExtensions: [h, hpp]
IncludeWhatYouUse:
  IncludeSuggester: true
  Preset: google
```

  

#### 2. 循环依赖检测（Graphviz可视化）

```Bash
# 生成依赖图
doxygen -g
dot -Tpng callgraph.dot -o dependency.png
```

  

#### 3. 编译时间优化（Precompiled Headers）

```C++
// pch.h 预编译头
#include <module_a/public/controller.h>  // 稳定的公共接口
#include <module_b/public/i_event_sink.h>

// CMake 配置
target_precompile_headers(module_a PRIVATE pch.h)
```

  

  

### 五、架构演进的3个阶段

#### 阶段1：应急解耦（快速处理现有依赖）

- 使用Pimpl隐藏实现依赖
    
- 为不可避免的依赖添加`// NOLINT(deprecated)`注释标记
    

  

#### 阶段2：接口重构（3-6个月）

- 定义跨模块的抽象接口（纯虚类）
    
- 通过依赖注入替换直接依赖
    

  

#### 阶段3：架构固化（1年+）

- 建立依赖规则检查（CI/CD必过项）
    
- 模块发布遵循SemVer 2.0（MAJOR.MINOR.PATCH）
    

  

  

### 六、典型案例：Chromium网络模块架构

```Plain
// 架构分层（简化版）
net/
├── public/           # 对外接口（仅头文件，无实现依赖）
│   ├── url_request.h  # 抽象请求接口
│   └── network_delegate.h
├── api/              # 平台无关实现
│   ├── url_request_impl.cc
│   └── network_stack.cc
├── internal/         # 平台特定实现（Win/Linux/Android）
│   ├── win/
│   └── linux/
└── BUILD.gn         # 依赖声明（明确模块间依赖关系）
```

  

#### 关键实践：

4. 所有模块通过`net::URLRequest`抽象接口通信
    
5. 平台相关代码隔离在`internal/`目录，通过编译宏选择
    
6. 禁止`api/`目录依赖`internal/`，确保跨平台一致性
    

  

### 七、总结：非完全模块化的架构设计

7. **接口优先**：通过纯虚类定义模块契约，实现与实现解耦
    
8. **分层控制**：强制单向依赖，核心模块下沉（如基础库→核心库→业务模块）
    
9. **依赖可视化**：使用工具链（CMake+Graphviz）实时监控依赖关系
    
10. **渐进式重构**：从应急解耦到接口重构，最终固化架构规则