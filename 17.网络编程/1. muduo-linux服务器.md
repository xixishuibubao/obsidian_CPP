# 1. 网络编程基础
## 1.1 通用流程
```C++
/*
1.先创建监听socket
*/

    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
   
/*
2.setsockopt设置端口复用，并bind绑定监听地址
*/

    int opt = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("bind 失败");
        close(listen_fd);
        return 1;
    }
    
/*
3.启动监听
*/
    if (listen(listen_fd, 5) == -1) {
        perror("listen 失败");
        close(listen_fd);
        return 1;
    }
/*
4.以某种方式监听到可读事件后就开始接收连接并保存新的fd
*/
    struct sockaddr_in cli_addr;
    socklen_t cli_len = sizeof(cli_addr);
    int conn_fd = accept(listen_fd, (struct sockaddr*)&cli_addr, &cli_len);
    
    if (conn_fd == -1) {
        perror("accept 失败");
        continue;}
            std::cout << "新连接：" << inet_ntoa(cli_addr.sin_addr) 
                      << ":" << ntohs(cli_addr.sin_port) 
                      << "（fd=" << conn_fd << "）"
                      << std::endl;
    }
/*
5.此时就可以对conn_fd进行操作了，每个conn_fd 都对应一个客户端链接
*/

    char buf[1024];
    ssize_t n = recv(conn_fd , buf, sizeof(buf)-1, 0);
    
    if (n <= 0) { // 客户端断开
    close(fd);
    std::cout << "客户端断开（fd=" << fd << "）" << std::endl;
    }
    
    
```
## 1.2 客户端
```C++
#include <iostream>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cstring>
#include <unistd.h>

int main(int argc, char* argv[]) {
    if (argc != 3) {
        std::cerr << "用法: " << argv[0] << " <服务器IP> <端口>" << std::endl;
        return 1;
    }

    // 创建socket
    int sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd == -1) {
        perror("socket 失败");
        return 1;
    }

    // 服务器地址
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_port = htons(atoi(argv[2]));
    if (inet_pton(AF_INET, argv[1], &serv_addr.sin_addr) <= 0) {
        perror("无效的IP地址");
        close(sockfd);
        return 1;
    }

    // 连接服务器
    if (connect(sockfd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("connect 失败");
        close(sockfd);
        return 1;
    }

    std::cout << "已连接到服务器，输入消息发送（输入q退出）：" << std::endl;
    char buf[1024];
    while (true) {
        // 读取用户输入
        if (fgets(buf, sizeof(buf), stdin) == nullptr) break;
        // 移除换行符
        size_t len = strlen(buf);
        if (len > 0 && buf[len-1] == '\n') buf[len-1] = '\0';
        if (strcmp(buf, "q") == 0) break;

        // 发送消息
        send(sockfd, buf, strlen(buf), 0);
        // 接收回显
        ssize_t n = recv(sockfd, buf, sizeof(buf)-1, 0);
        if (n <= 0) {
            std::cout << "服务器断开连接" << std::endl;
            break;
        }
        buf[n] = '\0';
        std::cout << "服务器回显: " << buf << std::endl;
    }

    close(sockfd);
    return 0;
}
```
## 1.3 select服务器(跨平台)
```C++
#include <iostream>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cstring>
#include <unistd.h>
#include <sys/select.h>

#define PORT 8888
#define MAX_CLIENT 1024  // 不超过FD_SETSIZE

int main() {
    // 创建监听socket
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) {
        perror("socket 失败");
        return 1;
    }

    // 设置端口复用
    int opt = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    // 绑定地址
    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("bind 失败");
        close(listen_fd);
        return 1;
    }

    // 监听
    if (listen(listen_fd, 5) == -1) {
        perror("listen 失败");
        close(listen_fd);
        return 1;
    }
    std::cout << "select服务器启动，端口 " << PORT << std::endl;

    fd_set read_fds;       // 读事件集合
    int max_fd = listen_fd; // 记录最大文件描述符

    while (true) {
        FD_ZERO(&read_fds);              // 清空集合
        FD_SET(listen_fd, &read_fds);    // 添加监听socket

        // 遍历所有可能的客户端socket，添加到集合
        for (int fd = 0; fd <= MAX_CLIENT; ++fd) {
            if (fd != listen_fd && fd > 0) {
                FD_SET(fd, &read_fds);
            }
        }

        // 等待事件（超时设为NULL，阻塞等待）
        int activity = select(max_fd + 1, &read_fds, nullptr, nullptr, nullptr);
        if (activity == -1) {
            perror("select 失败");
            break;
        }

        // 处理新连接
        if (FD_ISSET(listen_fd, &read_fds)) {
            struct sockaddr_in cli_addr;
            socklen_t cli_len = sizeof(cli_addr);
            int conn_fd = accept(listen_fd, (struct sockaddr*)&cli_addr, &cli_len);
            if (conn_fd == -1) {
                perror("accept 失败");
                continue;
            }
            std::cout << "新连接：" << inet_ntoa(cli_addr.sin_addr) 
                      << ":" << ntohs(cli_addr.sin_port) << "（fd=" << conn_fd << "）" << std::endl;

            if (conn_fd > max_fd) max_fd = conn_fd; // 更新最大fd
        }

        // 处理已连接客户端的消息
        for (int fd = 0; fd <= max_fd; ++fd) {
            if (fd == listen_fd) continue; // 跳过监听socket

            if (FD_ISSET(fd, &read_fds)) {
                char buf[1024];
                ssize_t n = recv(fd, buf, sizeof(buf)-1, 0);
                if (n <= 0) { // 客户端断开
                    close(fd);
                    std::cout << "客户端断开（fd=" << fd << "）" << std::endl;
                } else { // 回显消息
                    buf[n] = '\0';
                    std::cout << "收到fd=" << fd << "的消息：" << buf << std::endl;
                    send(fd, buf, n, 0); // 回显
                }
            }
        }
    }

    close(listen_fd);
    return 0;
}
```
## 1.4 poll服务器(win)
```C++
#include <iostream>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cstring>
#include <unistd.h>
#include <poll.h>

#define PORT 8888
#define MAX_CLIENT 1024

int main() {
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) {
        perror("socket 失败");
        return 1;
    }

    int opt = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("bind 失败");
        close(listen_fd);
        return 1;
    }

    if (listen(listen_fd, 5) == -1) {
        perror("listen 失败");
        close(listen_fd);
        return 1;
    }
    std::cout << "poll服务器启动，端口 " << PORT << std::endl;

    // pollfd数组：存放需要监听的文件描述符
    struct pollfd fds[MAX_CLIENT];
    fds[0].fd = listen_fd;    // 第0个位置放监听socket
    fds[0].events = POLLIN;   // 监听读事件
    int nfds = 1;             // 当前有效fd数量

    while (true) {
        // 等待事件（超时设为-1，阻塞等待）
        int activity = poll(fds, nfds, -1);
        if (activity == -1) {
            perror("poll 失败");
            break;
        }

        // 处理新连接
        if (fds[0].revents & POLLIN) {
            struct sockaddr_in cli_addr;
            socklen_t cli_len = sizeof(cli_addr);
            int conn_fd = accept(listen_fd, (struct sockaddr*)&cli_addr, &cli_len);
            if (conn_fd == -1) {
                perror("accept 失败");
                continue;
            }
            std::cout << "新连接：" << inet_ntoa(cli_addr.sin_addr) 
                      << ":" << ntohs(cli_addr.sin_port) << "（fd=" << conn_fd << "）" << std::endl;

            // 添加到pollfd数组
            if (nfds < MAX_CLIENT) {
                fds[nfds].fd = conn_fd;
                fds[nfds].events = POLLIN;
                nfds++;
            } else {
                std::cerr << "客户端数量已达上限" << std::endl;
                close(conn_fd);
            }
        }

        // 处理已连接客户端的消息
        for (int i = 1; i < nfds; ++i) { // 从1开始（0是监听fd）
            if (fds[i].revents & POLLIN) {
                char buf[1024];
                ssize_t n = recv(fds[i].fd, buf, sizeof(buf)-1, 0);
                if (n <= 0) { // 客户端断开
                    close(fds[i].fd);
                    std::cout << "客户端断开（fd=" << fds[i].fd << "）" << std::endl;
                    // 移除该fd（用最后一个元素覆盖）
                    fds[i] = fds[nfds - 1];
                    nfds--;
                    i--; // 回退一步，检查新移过来的fd
                } else { // 回显消息
                    buf[n] = '\0';
                    std::cout << "收到fd=" << fds[i].fd << "的消息：" << buf << std::endl;
                    send(fds[i].fd, buf, n, 0);
                }
            }
        }
    }

    close(listen_fd);
    return 0;
}
```
## 1.5 epoll服务器(linux)
```C++
#include <iostream>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <cstring>
#include <unistd.h>
#include <sys/epoll.h>

#define PORT 8888
#define MAX_EVENTS 1024  // 一次处理的最大事件数

int main() {
    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (listen_fd == -1) {
        perror("socket 失败");
        return 1;
    }

    int opt = 1;
    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));

    struct sockaddr_in serv_addr;
    memset(&serv_addr, 0, sizeof(serv_addr));
    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(PORT);
    if (bind(listen_fd, (struct sockaddr*)&serv_addr, sizeof(serv_addr)) == -1) {
        perror("bind 失败");
        close(listen_fd);
        return 1;
    }

    if (listen(listen_fd, 5) == -1) {
        perror("listen 失败");
        close(listen_fd);
        return 1;
    }
    std::cout << "epoll服务器启动，端口 " << PORT << std::endl;

    // 创建epoll实例
    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        perror("epoll_create1 失败");
        close(listen_fd);
        return 1;
    }

    // 添加监听socket到epoll
    struct epoll_event ev;
    ev.events = EPOLLIN;    // 监听读事件
    ev.data.fd = listen_fd;
    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &ev) == -1) {
        perror("epoll_ctl 添加监听fd失败");
        close(epoll_fd);
        close(listen_fd);
        return 1;
    }

    struct epoll_event events[MAX_EVENTS]; // 存放就绪事件

    while (true) {
        // 等待就绪事件（超时设为-1，阻塞等待）
        int nfds = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);
        if (nfds == -1) {
            perror("epoll_wait 失败");
            break;
        }

        // 处理所有就绪事件
        for (int i = 0; i < nfds; ++i) {
            if (events[i].data.fd == listen_fd) { // 新连接
                struct sockaddr_in cli_addr;
                socklen_t cli_len = sizeof(cli_addr);
                int conn_fd = accept(listen_fd, (struct sockaddr*)&cli_addr, &cli_len);
                if (conn_fd == -1) {
                    perror("accept 失败");
                    continue;
                }
                std::cout << "新连接：" << inet_ntoa(cli_addr.sin_addr) 
                          << ":" << ntohs(cli_addr.sin_port) 
                          << "（fd=" << conn_fd << "）" << std::endl;

                // 添加客户端socket到epoll
                ev.events = EPOLLIN;
                ev.data.fd = conn_fd;
                if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, conn_fd, &ev) == -1) {
                    perror("epoll_ctl 添加客户端fd失败");
                    close(conn_fd);
                }
            } else { // 客户端消息
                int fd = events[i].data.fd;
                char buf[1024];
                ssize_t n = recv(fd, buf, sizeof(buf)-1, 0);
                if (n <= 0) { // 客户端断开
                    close(fd);
                    std::cout << "客户端断开（fd=" << fd << "）" << std::endl;
                    // 从epoll中移除
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, fd, nullptr);
                } else { // 回显消息
                    buf[n] = '\0';
                    std::cout << "收到fd=" << fd << "的消息：" << buf << std::endl;
                    send(fd, buf, n, 0);
                }
            }
        }
    }

    close(epoll_fd);
    close(listen_fd);
    return 0;
}
```

# 2. muduo