## 1. 面向对象思想

### 1.1 what is OOP

#### 1.1.1 封装

类对象构造只是一个内存上的操作概念，他的行为仍旧取决于你的逻辑设计。

#### 1.1.2 继承->复用

在原有的框架之下拓展，譬如对Qt基础类的继承而后拓展自己的内容。

#### 1.1.3 多态->高内聚，低耦合

class 是批量制造对象的模板

#### 1.1.4 需求分解

将确切的事务，分解为抽象的逻辑和行为，并转化为接口实现，构建一个系统。

## 2. 类

### 2.1 语法层面技巧

#### 2.1.1 035法则

```C++
/*
<1> 0 : 尽量使用容器，避免手动管理内存。
<2> 3 : 拷贝构造函数，拷贝赋值函数，析构函数。
<3> 5 : 在3的基础上，增加移动构造函数和移动赋值函数。
      拷贝即形参为const classname&，
      移动则为classname&&,移动不带const,(否则移动的时候无法释放原有资源)
<4> 重载等号操作符一般返回原来对象的引用

注 : 
--- 拷贝构造，拷贝赋值，移动构造，移动赋值 算作一组A类方法---
// = delete也算自定义了该方法。
<1> 当你定义了显式带参构造函数而非默认生成的实现，那么系统将不会
     帮你生成默认的无参构造函数。
<2> 当你定义了移动或者拷贝函数，那么剩下的几个A类方法便不会自动生成
    默认实现，但是仍旧允许你使用 = default；获取默认实现。
<3> 当你定义了析构函数，那么不会自动生成移动相关的两个方法。
*/
```

#### 2.1.2 继承与访问

#####   2.1.2.1 权限控制

```C++
/* public, protected, private三种关键字，代表成员不同的访问权限等级。
<1> public 公有，基类，子类，外部都可直接访问。
<2> protected 保护，基类，子类，可访问；外部不可直接访问。
<3> private 私有，只能被类自己直接访问。
<4> friend 友元，友元可以修饰类或者函数，其访问权限等同基类自身
    (全部成员都可通过友元访问)，并且友元关系不会被继承或者传递。
    
继承体系：
- C++的类和结构体实际上是一样的，只是默认的访问权限不同。
- class 默认权限是 保护， struct 默认权限是 公有。
- struct 和 class是可以相互继承的，也可以各自继承对应类型。
*/
```

#####   2.1.2.2 单继承

```C++
/*
单继承：
<1> 友元关系不会被继承。
<2> 类和结构体可以相互继承。
<3> 继承时可以使用权限修饰，使得子类从父类继承来的权限不得高于该权限。
    高于该权限的则退化为该权限，低于的则保持不变。
<4> 单继承体系下，所有的函数都放在同一个虚表里，不论继承了多少次，
    最终都只有一个虚表。
*/
```

##### 2.1.2.3 多继承

```C++
/*
多继承：
<1> 可以多继承，一个子类可以继承多个父类，但要注意菱形继承问题。
<2> 多继承的继承顺序影响了内存布局。
<3> 虚继承 virtual 只需要在继承共同给的祖父类的时候用，后续再继承不需要用。
<4> 多继承体系下，每继承一个就多一个虚表。
<5> 虚表和虚基表最后是合并的，在第一个虚函数表的末尾就是虚继承的偏移

    内存布局如下
    ---start
    base1 虚表(当前类的虚表也在这里)
    base 成员
    ---
    base2 虚表 
    base2 成员
    ---其他父类
    当前类的成员变量
    ---end

    已经重实现的虚函数会在虚表直接覆盖父类函数，目前还没找到父类虚函数在哪里。
*/
```

##### 2.1.2.4 虚继承

虚继承常被用来解决菱形继承的问题，但是一般并不推荐使用虚继承和菱形继承的结构设计。

#### 2.1.3 构造的细节

  构造函数不可以当作成员函数访问，但是析构在特殊场景可以手动调用，譬如定位new构造，要配合手动析构。

```C++
A* val = new(arr) A; 
val->~A();
```

#####   2.1.3.1 显式构造

```C++
/* 
特定情况下子类需要显式的调用父类构造函数

<1> 父类无默认构造,父类没有 无参 / 全默认参数构造，
    或 default构造被删除,编译器无法自动生成调用
<2> 父类构造非 public,构造为 protected/private，
    子类只能在初始化列表中访问父类构造，权限控制强制显式
<3> 虚继承,最终子类需负责虚拟基类构造，中间类调用无效,
    构造顺序唯一性要求
<4> 父类是抽象类,抽象类构造需被实现类显式调用（即使无参数）,
    构造函数非虚，无法隐式调用
<5> 父类构造 explicit,禁止隐式转换，必须显式传递参数,
    类型安全强制。
    
    类的构造函数要注意,不带参数的构造函数和带默认参数的构造函数
之间会有重载冲突(未决)。
*/

class A{
public:
    explicit A(int a) {};/* explicit 关键字显式构造 */
};
```

##### 2.1.3.2 无参构造

```C++
/*
以下类A当隐式构造被调用的时候就会报错，因为编译器无法分辨，
无参构造和带默认参数的构造函数。

可以通过加 explicit 来前置要求显式构造，避免隐式转化。
*/


class A{
public:
    A(){}
    A(int c = 5){}

  //explicit  A(int a){}
};


 /*
 不可以使用譬如 A a();
 的方式来调用无参数构造函数，因为C++有一个原则，
 如果一个表达式可以被识别为函数声明，那么优先被识别为函数声明。
 所以 A a（）；是一个函数声明，而不是创建类对象。
 */
```

##### 2.1.3.3 初始化列表

```C++
/*
<1> 类的构造函数如果使用了参数初始化列表，要么直接在类内实现，
    或在类外实现的时候写上列表，声明的时候不写初始化列表。
<2> 类的初始化列表初始化顺序和成员的声明顺序有关，和列表顺序无关

注：
    C++11引入了对类成员变量的初始化优化，不管是给默认值，
还是初始化列表，以及{}统一初始化，还是建议用初始化列表。
初始化列表依赖于<initializer_list> 将形参设计为std::initializer<T>，
也可以实现自己的可以用{}列表作为实参传入的函数。
*/
```

#### 2.1.4 类作为传递参数

##### 2.1.4.1 形参为类对象

```C++
/*
class A{};
void fun(A a);

    类在作为形参用值传递的时候，首先会构造一个临时类对象。
然后会在函数结束调用析构函数，可能发生未定义的错误。避免
此类问题的最好办法是，避免使用值传递。同时给定重载=的构造
函数和形参为引用的构造函数。

    因为值传递产生临时对象就是会调用这两个其中一个构造，
没有给定就会实现一个默认的构造函数，常见的bug是对浅拷贝的
指针重复释放，编译器默认的构造函数在拷贝的时候不会给指针分配
新的内存空间，所以析构的时候会错误的释放掉原本不应释放的内存
而产生问题。
*/
```

#### 2.1.5 析构

##### 2.1.5.1 析构顺序

```C++
/*
    自动变量（局部变量和临时变量）的销毁和创建顺序是相反的。
这是因为他们在栈上，该行为是栈的性质，最先被创建的最后被销毁，
即先入后出。

void func()
{
    A a;
    B b;
}
    函数func依次构造了两个临时对象a和b，那么函数结束调用会
先析构b然后析构a。

*/
```

##### 2.1.5.2 手动析构

```C++
/*
<1>需要手动析构的场景一般是定位构造。
<2>new和malloc有一个本质区别就是，new会调用类的构造函数，
    malloc只分配内存并不构造。
<3>而定位new是个例外,要手动析构
*/
/* 也可以在new的内存上定位new 同样需要手动析构*/
/* 定位new只是在该地址调用对象的构造函数，不会自动向后更新
    对同一个地址去定位new 后面的会覆盖前面的 ，假如析构里涉及到了
    对内存的释放可能会有未定义行为*/
#include <new>

char arr[512] = {};
class A{};

int main()
{
    A* a= new(arr) A();
    a->~A();
    char* p = new char(100);
    A* b = new(p) A();
    b->~A();
    delete p;
}
```

#### 2.1.6 深浅拷贝

##### 2.1.6.1 深浅拷贝的区别

```C++
/*
    深拷贝和浅拷贝的主要区别是会不会为需要动态内存的地方重新申请内存。
深拷贝会申请，浅拷贝不会，编译器提供的默认的构造函数就是浅拷贝。

    有时，我们会在类对象的构造中使用new来申请内存，那么在
析构函数中我们应当调用delete，并且delete是可以释放空指针
(NULL/nullptr)的，此时他什么也不会发生。
    当你申请的内存是以数组形式申请的，譬如int* p = new int[10]；
那么释放的时候也要对应，使用delete[] p;当然当使用普通的new
只需要调用delete即可。
*/
```

  

<5>const成员和引用成员在初始化时应当使用参数列表初始化，使用 classname（）：const成员1 = val1，const成员2 = val2｛｝的形式初始化。普通成员也可以这样这样初始化。但是const成员和引用成员只能这样初始化。因为引用和const只能初始化一次，所以要在构造的同时初始化。

#### 2.1.7 虚函数

##### 2.1.7.1 成员函数虚函数

```C++
/*
父类需要被子类重写的函数要声明为虚函数，
virtual在最前面修饰,这告诉子类可以重写父类方法，
同时子类重写父类方法要在函数声明尾部加上override表明是重写的父类方法。
*/

class A{
public:
    virtual void func(){}
};

class B:public A{
public:
    void func() override{}
};
```

##### 2.1.7.2 析构函数虚函数

```C++
/*
    父类的析构函数应当声明为虚函数，
有时我们会出现父类指针或者引用指向一个子类对象的情况。

    此时假设不使用同名虚函数和虚析构，那么优先按照类型
访问父类方法而不是正确的子类方法。
    
    不使用虚析构，可能会产生内存泄露，因为此时父类指针
指向子类时，子类析构是不会被自动调用的，将会按照变量类型
调用父类析构，而不是实际的子类析构。
    
    当调用结束时，会优先调用子类析构，再调用父类析构。
*/
```

#### 2.1.8 this指针

##### 2.1.8.1 概念与用法

```C++
/*
this指针是一个C++很早就引入的概念，主要有四个作用：
<1>可以在成员函数内部使用this->成员变量的方式，来处理外部变量和成员变量同名的情况。
<2>返回自身的引用实现链式调用，return *this；
<3>作为参数在自己的成员函数内传递。
<4>构造函数重载调用另一个构造函数，此时是隐式的调用了this，先创建对象，
    然后用了this 指针去初始化。
<5>同时在重载=运算符的时候，要在内部对this == &value 这种情况做判断。
*/
```

#### 2.1.9 同名变量和方法

##### 2.1.9.1 类内优先原则

```C++
/*
    在类中，成员函数优先查找成员变量和成员函数使用，
在没有同名成员变量和函数才调用外部全局，如果都没定义就报错，
一般推荐显式的使用全局变量 如 ::a = 5；对全局变量a赋值5。
成员函数可以在类内直接定义，也可以在类外定义。
*/

int k = 0;

class aaa
{
pubilc:
    void set(int a);
   
private:
    int k;
}

void aaa::set(int a){
/* 将a赋值给全局k，而后将a赋值给类内私有k*/
    ::k = a;
      k = a;
}
```

#### 2.1.10 mutable与const

##### 2.1.10.1 const后置

```C++
/*
const 后置是类成员函数的修饰符，标识该函数不会修改成员变量。
const方法不可以调用其他非const方法，但是可以调用其他非const变量。
const后置的方法中，this 的类型是const class*；
而const 对象只可以调用const方法。


const 后置也是一种签名标识符，即便形参一致也会被重载识别。
const返回值差异则不能被识别为两种重载。

还有引用后置也是标识符(针对成员函数可用)，
void func()&;
void func()&&;
void func();
分别代表 左值对象可用，右值对象可用，通用可用。
但是这前两个不可以和第三个同时出现，否则会产生重载冲突。
*/
#include <iostream>
class A{
private:
    int c;
public:
	void func() const { std::cout << c << std::endl; }
}
```

##### 2.1.10.2 mutable

```C++
/*
mutable 是一个只属于lambda和成员变量的修饰符，
用以标识变量可修改。

const方法可以修改被mutable修饰的值。
*/
#include <iostream>

class A {
public:
    mutable int c{1};
    void func() const {
        std::cout << c << std::endl;
        c++;
    }
};

int main() {
    A a;
    a.func();
    a.func();
    return 0;
}
```

##### 2.1.10.2 const对象

```C++
/*
const 对象只能调用const方法，不能调用非const方法。
const 对象可以访问非const成员变量。

C++中const 修饰的变量可以放在.h文件被直接包含，具有内链的静态特性。
但在C中const 修饰的变量不可以直接定义在.h文件中，因为C中是具有外链性的。
*/

```

#### 2.1.11 静态成员

##### 2.1.11.1 静态成员

```C++
/*

<1>类的静态成员(不论是函数还是还是变量)，都只能操作同样静态的成员，
因为静态成员不与类对象绑定，而是与类本身绑定。
    这是一种类似const调用的关系，只能是不稳定的调用稳定的，
反之则不允许。
<2>C++11以前静态成员要定义在类外部，C++11之后可以内联定义在类内。
*/

class A {
    inline static int c = 1;
};

class B {
    static int c;
};

int B::c = 1;
```

#### 2.1.12 别名using/typedef

##### 2.1.12.1 using

```C++
/*
    C++11 对using的用法进行了扩展，可以使用using为类型设置别名。
*/

class A { };
using B = A;

int main() {
    B a;
    return 0;
}

/*
    尤其是配合模板类更加好用
*/
template<typename T1, typename T2>
class A {
    using type1 = T1;
    using type11 = typename T1::it::type;
};

template<typename T>
using B = A<int, T>;

using C = A<int, int>;
template<>
class A<int,int> {
    
};
```

##### 2.1.12.1 typedef

```C++
/*
    typedef 属于老派用法，兼容C语言，但是typedef无法对
偏特化模板使用。无法像对结构体一样，定义的同时给定别名。
以下是正确使用。
*/

template<typename T1, typename T2>
class A {
};

typedef A<int, int> C;
#if 0
/*
错误用法
*/
template<typename T>
typedef A<int,T> CC;
#endif
```

#### 2.1.13 成员命名

##### 2.1.13.1 命名法则

```C++
/*
    类型名 大驼峰(类名，模板参数)

    成员变量名 m_前缀 或者 _后缀 ，不要使用_前缀，
前置_是标准库和编译器的保留用法。整体命名是unix风格，
全小写下划线。

    结构体成员变量是不加_后缀的，但也遵循unix风格。

*/
```

#### 2.1.14 友元

##### 2.1.14.1 友元关系

```C++
/*
<1>友元只针对当前类/函数，友元不会被继承。
<2>类的成员函数是自身类型的友元，可以访问形参的私有成员。
*/
/*
<1>友元只针对当前类/函数，友元不会被继承。
<2>类的成员函数是自身的友元，可以访问形参的私有成员。
*/
#include <iostream>

using namespace std;

class B;

class A {
    friend void fff(const A *);
    friend class B;

private:
    int val{2};

public:
    void fun(const A *o) { std::cout << o->val << std::endl; }
};

class B {
public:
    static void func(const A *a) {
        std::cout << a->val << std::endl;
    }
};

void fff(const A *a) {
    std::cout << a->val << std::endl;
}

int main() {
    A a;
    A a2;
    B::func(&a);
    fff(&a);
    a.fun(&a2);
    return 0;
}
```

##### 2.1.14.2 对内友元

```C++
/*
    类本身对自己的类型是友元的，所有的成员函数，本质是
一个带隐藏参数的普通函数。其第一个隐藏参数就是类的this指针。
*/
class A{
    void func(/* A* this */int a);
}
```

##### 2.1.14.3 友元重载操作符

```C++
/*
<1>对于<<符号的重载使用全局操作函数，而不是成员函数。
<2>根据需求来决定要不要友元，如果只访问公开成员是不需要友元的。

重载 << 其返回值为ostream&，第一个形参也是ostream&，且不必传递第一个参数
*/
std::ostream& operator << (std::ostream& os, const A& a) { }
```

  

#### 2.1.15 final

##### 2.1.15.1 final 不可重实现/继承

```C++
class A final{ }; /* A 不可被继承*/
/* 不可再次重实现 */
using namespace std;

class B {
public:
    virtual void func() {
        cout << "B::func()" << endl;
    }
};

class C : public B {
public :
    void func() override final {
        cout << "C::func()" << endl;
    }
};

class D : public C {
}; /* func 不可再次虚函数重实现*/
```

### 2.2 技法层面技巧

#### 2.2.1 RAII

```C++
/*
    Resource Acquisition Is Initialization 资源获取即是初始化。
使用构造函数来管理获取资源，析构函数来释放资源。
*/
```

#### 2.2.2 RTTI

```C++
/*
    Run-Time Type Identification 运行时获取类型。
typeid(val).name();可以使用typeid来获取带有虚函数的类的信息。
name是一个复合名称，是基础类型缩写或类名长度+类名。

    RTTI有一定的性能损耗。
*/
```

#### 2.2.3 PIMPL

##### 2.2.3.1 pimpl介绍

```C++
/*
<1>pimpl主要是为了避免暴露实现细节。
<2>以指针包含p_impl资源，将变量封装以保证安全，
<3>pimpl是Qt::Ui常用的做法，一般设计成内部类就好了，和外部类可以放在一起实现。
*/
```

##### 2.2.3.2 pimpl方案

- <1>嵌套命名空间法
    

```C++
/*头文件 module.h*/
namespace my_module {
    class Module {
        /*前向声明*/
        struct Impl;
        Impl *impl_;
    };
}

/* 要点就是命名空间要一致*/
/*detail 实现层*/
/*module.cpp*/
namespace my_module {
    struct Module::Impl {
    };
}
```

  

- <2>匿名命名空间与void*
    

```C++
/*头文件 module.h*/
class Module {
    Module();
    ~Module();

    void *impl_;
};

/*detail 实现层*/
/*module.cpp*/
#include "module.h"

namespace {
    struct Impl {
        /*一些数据*/
    };
}

Module::Module() : impl_(new Impl) {
}

Module::~Module() { delete static_cast<Impl *>(impl_); }
```

- <3>配合using的命名空间隔离
    

```C++
/* 头文件（public.h）*/
namespace my_module {
    class DataProcessor {
    private:
        using Impl = detail::DataProcessorImpl; /*类型别名（带命名空间）*/
        std::unique_ptr<Impl> pimpl_;
    };
} /* namespace my_module*/

/* 内部头文件（detail/impl.h）*/
namespace my_module::detail {
    struct DataProcessorImpl {
        // 实现命名空间
        int buffer_size;
    };
} /* namespace my_module::detail*/

/* 实现文件（data_processor.cpp）*/
#include "detail/impl.h"

namespace my_module {
    DataProcessor::DataProcessor()
        : pimpl_(std::make_unique<detail::DataProcessorImpl>()) {
    }
}
```

- <4>带模板优化的隔离impl
    

```c++
/* 编译单元内的类型安全封装（.cpp）*/
namespace {
    template<typename T>
    struct OpaquePtr {
        void *ptr;

        T *operator->() const {
            return static_cast<T *>(ptr);
        }
    };

    struct Impl {
    };
}

/* 模板避免了手动cast的长书写麻烦,适合多次使用impl的场景 */
MyClass::MyClass() : impl_(new Impl) {
}

void MyClass::PublicMethod() {
    OpaquePtr<Impl> test{impl_};
    test->client.DoSomething(); /* 直接调用，无额外开销 */
}
```

  

- <5>模板基类的impl
    

```C++
/* 通用Pimpl基类（header-only）*/
template<typename Derived>
class PimplBase {
protected:
    struct Impl {
        virtual ~Impl() = default;
    };

    std::unique_ptr<Impl> pimpl_;
    Derived& derived() { return static_cast<Derived &>(*this); }
};

/* 具体类实现*/
class Database : private PimplBase<Database> {
private:
    struct Impl : PimplBase<Database>::Impl {
        /* 继承通用Impl*/
        sqlite3 *db;
    };

    friend class PimplBase<Database>;
};
```

  

- <6>代理类impl与->穿透
    

```C++
/* 当嵌套的代理类都重载了->，可以在最外层直接用->访问到最内层的数据。*/
/* 头文件（仅暴露接口，无类型信息）PhysicsWorld.h*/
class PhysicsWorld {
public:
    auto operator->() const noexcept; /* 重载->，返回代理类*/
    /* auto 作为返回值是C++14引入的，
    C++11需要配合后置类型->decltype(表达式) */
private:
    void *impl_ = nullptr; /* 不透明指针*/
};


/*实现+定义pimpl文件 PhysicsWorld.cpp*/
namespace {/* 编译单元本地作用域*/
    struct Impl {/* 隐藏的具体实现*/
        float simulation_time = 0.5f;
    };

    /* 代理类：重载->操作符的核心,这里实际上可以做成模板*/
    class Proxy {
        void *ptr_;

    public:
        explicit Proxy(void *ptr) noexcept : ptr_(ptr) { }

        /*支持箭头操作（如->frame_count）*/
        auto operator->() const {
            return static_cast<Impl *>(ptr_);
        }
    };
} /* namespace*/
/*接口实现*/
PhysicsWorld::PhysicsWorld() {
    impl_ = new Impl{};
}

PhysicsWorld::~PhysicsWorld() {
    delete static_cast<Impl *>(impl_);
}

auto PhysicsWorld::operator->() const noexcept {
    return Proxy{impl_};
}

#include <iostream>

int main() {
    PhysicsWorld a;
    std::cout << a->simulation_time; /*成功打印0.5*/
}
```

- <7>带静态成员函数impl
    

```C++
/*实现文件 PhysicsWorld.cpp*/
namespace {
    struct Impl {
        static void SimulateImpl(void *self) {
            /* 静态成员函数*/
            auto *impl = static_cast<Impl *>(self);
            /* 对impl操作 */
        }
    };
}

void PhysicsWorld::Simulate() {
    Impl::SimulateImpl(impl_); /* 正确：静态函数直接调用*/
}
```

- <8>成员指针代替函数的impl
    

```C++
/* 实现文件 */
namespace {
    struct Impl {
        using SimulateFunc = void()(void); /* 函数指针类型*/
        SimulateFunc simulate; /* 成员函数指针（非静态）*/
        Impl() : simulate(&SimulateImpl) {
        } /* 初始化函数指针*/
    private:
        static void SimulateImpl(void *self) {
            auto *impl = static_cast<Impl *>(self);
            /* 操作impl */
        }
    };
}

void PhysicsWorld::Simulate() {
    auto *impl = static_cast<Impl *>(impl_);
    impl->simulate(impl_); /*✅ 函数指针调用，无符号导出*/
}
```

  

#### 2.2.4 类型转化

##### 2.2.4.1 使用关键字

```c++
/* c++有四种类型转化（c的强制转化也能用）
 
<1>static_cast 静态转换，主要转换基本类型之间的行为，
对于不含有继承关系的结构体和类指针与其他类型的转化也用这个
<2>dynamic_cast 静态转换，主要转换父类与子类指针，转化失效
会返回nullptr，会对两者的继承关系做检查,同时要求父类有虚表，
假设只继承无虚函数，也不应当使用dynammic_cast，应该使用static_cast
<3>const_cast 用于将const/volatile变量转化为非const/volatile变量，
修改其读写属性。
<4>reinterpret_cast 类似C的强制转化，实现最底层（字节级别的）的类型转化。
 
在C++中 转化使用<>而不是(),同时变量本身也加上( )。例:
*/

int a = static_cast<float>（b）；
```

##### 2.2.4.2 使用代理类模板

```C++
template<typename T>
class ProxyCast {
private:
    T *p_;

public:
    explicit ProxyCast(void *p) {
        p_ = static_cast<T *>(p);
    }

    T *operator->() const {
        return p_;
    }

    T *get() const {
        return p_;
    }

    T &operator*() const {
        return *p_;
    }
};

struct A {
    int c = 1;
};

int main() {
    ProxyCast<A> p(new A());
    cout << p->c << endl;
    cout << p.get()->c << endl;
    cout << (*p).c << endl;
}
```

##### 2.2.4.3 重载类型转化符

```C++
/*
<1>重载类型转化符不需要在函数声明写返回值 也不需要void，因为目标类型已经
可以代表返回值类型，但是要return 目标类型的值。
<2>重载<<输出到cout，推荐使用友元全局，因为如果是成员函数，<<第一个参数是this，
但是又由于cout的需要，第一个参数应当是ostream&；故而推荐全局<<重载。
<3>一定要在<<重载函数中return os；否则会发生异常。
<4>重载的类型转换符号也可以使用explicit 和const后置，可以使用很多构造函数的修饰符。
*/

class A {
    int a_;

public:
    explicit A(int a) : a_(a) {
    }
    /* 友元重载的<<*/
    friend ostream &operator <<(ostream &os, const A &aa);
};

ostream &operator <<(ostream &os, const A &aa) {
    os << "this is A::a_ is " <<aa.a_ << endl;
    return os;
}

class B {
    int b_ = 2;

public:
    explicit operator A() const{
        return A(b_);
    }
};

int main() {
    B b;
    cout << static_cast<A>(b) ;
    cout << static_cast<A>(b);
}
```

  

#### 2.2.5 初始化

##### 2.2.5.1 初始化列表

```C++
/* C++11引入了初始化列表：
<1>使用：val_（val）的方式就是类的初始化列表，其初始化效率比
在{}内赋值要高,依赖于std::initializer_list<T>。
其等价于 A(std::initializer_list<T> list){}
*/
class A {
    int a_;
    int b_;

public:
    explicit A(int a, int b): a_(a), b_(b) { }

};
```

  

##### 2.2.5.2 统一初始化

```C++
/* C++11引入了{]统一初始化方式，其底层依赖是std::initializer_list<T>
多种初始化方式：
<1>int a = 1;
<2>int a(1);
<3>int a{1};

并且C++11还支持对类的成员变量给默认值,但是不支持val()的形式。
*/

class A {
    int a_{1};
    int c_ = 3;
};
```

  

## 3.模板

### 3.1 模板类

#### 3.1.1 泛型实现

STL容器大都是基于模板实现的，想要研究模板思想可以参考STL学习其结构设计。

```C++
#include <iostream>

template<typename T>
class ProxyCast {
private:
    T *p_;

public:
    explicit ProxyCast(void *p) {
        p_ = static_cast<T *>(p);
    }

    T *operator->() const {
        return p_;
    }

    T *get() const {
        return p_;
    }

    T &operator*() const {
        return *p_;
    }
};


int main() {
    int *p = new int(1);
    ProxyCast<int> val(p);
    cout << *val.get();
    delete p;
}
```

  

#### 3.1.2 特化实现

偏特化即部分模板参数预填充,全特化即完全填充模板参数。

```C++
/*
    根据最优匹配原则，当模板匹配时，优先级：
全特化 > 偏特化 > 泛型；
*/
/*泛型*/
template<typename T1,typename T2>
class Test { };

template<typename T>
using Testi = Test<int,T>;

using Testii = Test<int,int>;

template<typename T1,typename T2>
class Test { };

/* 偏特化 */
template<typename T>
class Test<int,T> { };
/* 全特化 */
template<>
class Test<int,int> { };
```

  

#### 3.1.3 特殊特化

```C++
/*
有时我们会根据指针和引用来特化模板。这些也是泛型编程(偏特化)
*/
template<typename T1, typename T2>
class A {
    public:
};

template<typename T1, typename T2>
class A <T1&,T2&>{
public:
};

template<typename T1, typename T2>
class A <T1*,T2*>{
public:
};
```

#### 3.1.4 CRTP奇异递归

```C++
/*
CRTP可以实现类似虚函数的效果，且没有虚函数的开销。
本质就是继承一个模板参数为当前类的模板类。
并且记得友元一下父类。
*/
template<typename T>
class A {
public:
    void func_a() {
        static_cast<T *>(this)->func();
    }
};

class B : public A<B> {
    friend class A<B>;/*  友元父类 */

    void func() {
        cout << "B::func()" << endl;
    }
};

int main() {
    B b;
    b.func_a();
}
```

  

### 3.2 模板函数

#### 3.2.1 泛型

```C++
template<typename T1, typename T2>
T1 func(T1 t1,T2 t2) { return t1; }

int main(){
    func<int,int>(1,2);
}
```

  

#### 3.2.2 重载

```C++
/*
虽然看似和模板类一样，但是函数没有偏特化，实际上是重载实现的类似偏特化的效果。
*/
template<typename T1, typename T2>
T1 func(T1 t1,T2 t2) { return t1; }

template<typename T>
T func(T t1,int t2) { return t1; }

template<>
char func(char t1,int t2) { return t1; }
```

### 3.3 最优匹配原则

#### 3.3.1 通用准则

```C++
/*
对于重载函数的最优匹配原则如下：
<1>完全匹配(包括const修饰符，但是这里只针对&和*生效，因为const type和type具有
    二义性不能重载)，常规函数优于模板
<2>提升转换，char/short提升为int，float提升为double
<3>标准转换，int 转 char，long转double。
<4>用户声明的类型转换

如果最优匹配是模板函数，那么具体模板函数优于通用模板函数。
在形参中，&引用和本体被视为同一特征，尤其是在重载的时候，他们属于完全匹配的序列。
当重载函数存在模板和非模板的匹配函数时，可以使用 void pfunc1<>(形参)的方式来使用
模板函数，也可以在<>中写明具体哪个模板类

全特化 > 偏特化 > 泛型模板
*/
```

  

### 3.4 decltype类型推导

#### 3.4.1 定义和用法

```C++
/* C++11引入的类型推导decltype，常用来配合auto，做后置返回类型。
    
    decltype的参数必须是表达式不能是类型。
<1>decltype类似typeof的一个C++11特性关键字，使用方法如下：

    int a; 
    decltype(a) b;
    
    定义了一个类型同a的b变量。decltype()也可以将函数作为参数，将会定义一个
和返回值同类型的变量，但是他只是查找原型，不会调用函数本体。
    
    假如在decltype()内又()会导致其变成&,譬如
    
    decltype((a)) b = c;
    此时b是int&;
    decltype 还可以配合typedef使用，例如 typedef decltype(x+y) typec;
此时你就得到了类型typec。
    
    另外就是 引用的加减乘除以后的值是原类型，而不是引用类型。
    对于多模板的模板函数，decltype在其内部并不好用，所以有了auto 函数原型 -> type {}
或者是 auto 函数原型 -> decltype() {} 的形式，表明你可以在多模板的情况之下，提前获取
变量类型。
*/


/* 以下是一个用到该技术的线程池开源库*/
/* thread_pool.hpp */
#include <vector>
#include <queue>
#include <memory>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <future>
#include <functional>
#include <stdexcept>

class ThreadPool {
public:
    ThreadPool(size_t);
    template<class F, class... Args>
    auto enqueue(F&& f, Args&&... args) 
        -> std::future<typename std::result_of<F(Args...)>::type>;
    ~ThreadPool();
private:
    // 工作线程
    std::vector< std::thread > workers;
    // 任务队列
    std::queue< std::function<void()> > tasks;
    
    // 同步
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop;
};

// 构造函数初始化线程池
inline ThreadPool::ThreadPool(size_t threads)
    :   stop(false)
{
    for(size_t i = 0; i < threads; ++i)
        workers.emplace_back(
            [this]
            {
                for(;;)
                {
                    std::function<void()> task;
                    
                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        this->condition.wait(lock,
                            [this]{ return this->stop || !this->tasks.empty(); });
                        if(this->stop && this->tasks.empty())
                            return;
                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }
                    
                    task();
                }
            }
        );
}

// 提交任务到队列
template<class F, class... Args>
auto ThreadPool::enqueue(F&& f, Args&&... args) 
    -> std::future<typename std::result_of<F(Args...)>::type>
{
    using return_type = typename std::result_of<F(Args...)>::type;

    auto task = std::make_shared< std::packaged_task<return_type()> >(
        std::bind(std::forward<F>(f), std::forward<Args>(args)...)
    );

    std::future<return_type> res = task->get_future();
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        
        // 线程池已停止时拒绝任务
        if(stop)
            throw std::runtime_error("enqueue on stopped ThreadPool");
        
        tasks.emplace([task](){ (*task)(); });
    }
    condition.notify_one();
    return res;
}

// 析构函数终止所有线程
inline ThreadPool::~ThreadPool()
{
    {
        std::unique_lock<std::mutex> lock(queue_mutex);
        stop = true;
    }
    condition.notify_all();
    for(std::thread &worker: workers)
        worker.join();
}

#include <iostream>


int main() {
    // 创建包含 4 个线程的线程池
    ThreadPool pool(4);
    // 提交任务并获取返回值
    auto result = pool.enqueue([](int answer) { return answer ; },42);
    std::cout << "Result: " << result.get() << std::endl;  // 输出: 42

    // 提交多个任务
    std::vector< std::future<int> > futures;
    for(int i = 0; i < 8; ++i) {
        futures.emplace_back(
            pool.enqueue([i] {
                std::this_thread::sleep_for(std::chrono::seconds(1));
                return i*i;
            })
        );
    }

    // 等待所有任务完成并输出结果
    for(auto &f: futures)
        std::cout << f.get() << " ";
    std::cout << std::endl;

    return 0;
}
```

  

## 4. C++11

### 4.1 新关键字

#### 4.1.1 noexcept

不抛出异常，常用来配合移动语义。

移动构造和移动赋值使用noexcept 可以进一步优化，尤其是自定义的容器扩容时。

```C++
class A {
public:
    A(A &&oth_) noexcept;
    A &operator=(A &&oth_) noexcept;
};
```

#### 4.1.2 =delete，=default

```C++
/*
    只可以用于构造函数。
*/
class A
{
    A() = default；/*生成默认构造*/
    A(const A&) = delete;/* 禁止默认生成的拷贝构造*/
};
```