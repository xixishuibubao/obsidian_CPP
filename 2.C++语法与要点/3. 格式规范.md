## 1. 命名规范

1. 自定类型使用大驼峰
2. 变量和参数使用小驼峰
3. `namespace` 全小写
4. 宏使用大写加下划线
5. 常量和枚举使用 k 小驼峰

## 2. 代码格式规范

1. `{`在函数名行尾，右花括号换行。
2. 空实现放在函数名同一行,`void func() { }`。
3. `{`和函数名要有一个空格缩进，`void func() {`。
4. 参数超长时要换行:
   - 可以参数开始换行然后缩进 4 空格/1 个 `tab`。
   - 可以换行使得每个参数一行。
5. `if `和 `while` 一定加`{}`。
6. 空循环体和语句在同行，并使用内部包含一个空格的`{}` ,`while(i < 10) { }`。
7. `switch`、`case`、`break` 三者逐级缩进，
   且 `case` 的`{`与`:`有一个空格，`}`和` case`对齐。
8. 换行时，要让运算符号或者逗号在末尾。
9. 每行只初始化一个变量。
10. 初始化换行要 4 空格缩进/1`tab`。
11. 涉及到`#`的预处理命令不缩进，一律放在行首。

## 3. 类的设计规范

1. 类的构造函数类内声明，类外实现时，参数列表可以只在外部实现处写出，而不必在声明处写出。
2. 头文件应当自包含，可以独立编译，就是将其他依赖文件在`.cpp `包含。
   - 配合前向声明，在`.h` 处声明依赖类型`class`，在`.cpp`包含实际依赖的`.h`。
   - 最好将依赖设计成类内的成员指针，这样每次修改可以减少编译时间。
3. 对于标准库，可以使用延迟包含。不在`.h`包含，只在`.cpp`包含需要的标准库。
4. `namespace {}`匿名空间具有内链属性，只在当前文件可见，类似于`static`，并且也支持类外实现，类内声明。
5. 使用`explicit`，将`explicit`放置在类的单参数构造函数之前修饰，可以避免一些意外的隐式转化，这使得该函数不会被当作隐式转化函数，这是 C++11 引入的。
6. 对于不需要拷贝构造(形参为`type&`)，和赋值操作符`=`的类，可以将这两个放在私有作用域，并且不实现，这样可以避免外部错误的调用。
7. `constexpr`修饰函数表示函数在编译时就可以获取返回值常量。
   - 接收该返回值的变量，以及间接或直接使用返回值的变量都应当使用`constexpr`修饰。
   - `constexpr`变量和非`constexpr`变量在编译期求值一个是错误行为，编译会失败。
   
8. `final`表示不可继承不可重写，可以在继承时使用也可以在重写虚函数时使用。
   - `final` 修饰的类不可被再次继承，`final`修饰的函数不可被再次重写。譬如:
     - `class A : final public B { };` 那么 A 不可被再次继承。
     - `class A : public B { void func1() final override { } }`,func 是父类的虚函数，那么继承 `A` 的子类不可重写 `A` 的 `func1`，并且 `final` 和 `override` 不分先后顺序，这是 C++11 引入的特性。

9. 虚继承 `virtual`: 虚继承可以使得多继承时，不会出现继承冲突。
   - `class D : virtual public A { }; class E : virtual public A { };`
   - `class F : public D, public E { };`此时 `F` 类可以正常访问来自原始父类 `A` 的成员，虚继承会有一定开销，但编译器会优化。
   
10. 拷贝构造函数`A(A&){ }`和拷贝赋值函数`A& operator=(A&){ }` 应当成对出现和禁止。移动构造函数`A(A&&){ }`和移动赋值函数`A& operator=(A&&){ }`应当成对出现禁止。

11. 禁止在构造函数调用虚函数。子类构造和析构的调用顺序如下：
	- 构造：先调用父类构造，再调用子类构造。
	- 析构：先析构子类，再析构父类。
12. 父类的析构函数应当声明为虚函数，以避免内存泄漏。
	- 使用父类指针和引用承接子类对象，析构不会正确调用子类析构，需要声明父类析构为虚函数。
	- 只使用子类指针和引用承接子类对象，可以不虚函数父类析构，但虚函数父类析构也不会有影响，故而析构应当为虚函数。
13. 禁止虚函数使用缺省默认值(即不允许使用默认参数)。
14. 禁止重定义父类非虚函数，由于不是虚函数，不会被多态，反而容易引起歧义。
15. 多继承主要用于接口隔离和功能组合，譬如同时继承来自不同基类的派生功能类，那么继承后的类就具有以上的全部接口。

## 4. 类型转化与参数

1. 优先使用枚举作为参数，而不是`define`，因为`define` 没有类型检查
2. C++类型转化:
	- `dynamic_cast<类型>(变量)`：主要用于父类指针向子类指针转换。转换成功则返回指针，失败则返回 `nullptr`。
	- `static_cast<类型>(变量)`：用于如基本类型之间的转换、子类指针向父类指针转换。但不进行类型检查，因此存在风险。
	- `reinterpret_cast<类型>(变量)`：用于底层的、不安全的类型转换，通常是对指针类型转换，是基于内存的转化，容易导致未定义行为，应尽量避免使用。
	- `const_cast<类型>(变量)`：主要用于去除或添加变量的`const`或`volatile` 属性。但可能破坏常量的语义，去除`const`后不能通过该指针修改常量的值，否则会导致未定义行为。
	- `dynamic_cast`依赖`RTTI`,使用该操作符的时候不可以在编译选项禁用`RTTI`
    

## 5. C++11 以后特性

1. 使用`nullptr`而不是`NULL`。C++11 特性
2. 对于不需要拷贝构造(形参为&)，和赋值操作符(=)的类。
   可以使其` func() = delete;` 来删除该方法。 C++11 特性
3. 父类虚函数使用`virtual`，子类重写使用`override`，便于匹配检查。C++11特性
4. 使用`using`而不是`typedef`来定义类型别名，`using`可以对模板类型别名。
   - 语法使 `using newname = oldname;`
   - `typedef` 要想对带模板参数的类型别名，需要使用结构体封装一层。C++11特性
5. 禁止使用`std::move`操作`const`变量,`const`不可修改，也不可移动。C++11特性
6. 智能指针，优先使用`unique_ptr`，而不是`shared_ptr`，`shared_ptr`具有明显的开销。C++11特性
7. 使用`make_unique`来创建`unique_ptr`而不是`new`，`make_unique`只有一个类型参数，可以减少类型错误的风险。C++11特性
8. 同理使用`make_shared`创建`shared_ptr`。C++11特性
9. 智能指针实现自定义类型的`deleter`的时候，就不应当使用原生`make_`，应当在命名空间实现自己的`make_`和`deleter`。C++11特性
10. `Lambda`表达式(又称匿名函数)，不能捕获局部变量也不能局部声明，能用函数就不要用 `lambda`表达式。C++11特性
11. 所有权与形参(C++11特性)
	- 不涉及所有权的时候使用 `T`或者`T*`做形参。
	- 涉及到所有权的时候，可以将形参声明为`unique_ptr<T>`或者其他智能指针类型。
12. `gsl::not_null`，`GSL`是一个外部库。C++14特性
13. 模板元可以理解为对模板的一种特殊使用，可以在编译时就获取需要的返回值。
    - 使用`enum`是有深意的，因为枚举可以在编译期就确定值，使用 `const` 也可以但是不推荐。模板是 C++98 引入的。
    - ```C++
		template<uint32_t N>
		class Test{
		public:
			enum {number = Test<N-1>::number + Test<N-2>::number};
		};
		
		template<>
		class Test<0>{
		public:
			enum {number = 0};
		};
		
		template<>
		class Test<1>{
		public:
			enum {number = 1};
		};
      ```

14. 元组 `std::tuple`，有点类似结构体，但是他只能通过索引访问，其元素变量是没有名字的。头文件`<tuple>`

## 6. 内存管理与其他

1. `new`和`delete`,`new[]`和`delete[]`应当成对出现。
2. 类应当充分利用 `RAII` 特性(获取同时初始化)，构造时获取资源，析构时释放资源，这样可以避免手动申请和释放资源。
3. 不要保存`string`的`c_str()`返回指针，他的生命周期不确定。
4. `noexcept`不抛出异常修饰词，用在函数形参列表`()`后，使用`noexcept`修饰会让编译器对其更大程度的优化。C++11 特性。
