模板是C++98引入的，模板元可以理解为对模板的一种特殊使用，可以在编译时就获取需要的返回值。

譬如：

template <int N>

struct Factorial {

enum { value = N * Factorial<N - 1>::value };

};

  

template <>

struct Factorial<0> {

enum { value = 1 };

};

const int fib = Factorial<10>::value; <>内必须是确定的值，不能是运行中获取的动态值。

同时这里使用enum是有深意的，因为枚举可以在编译期就确定值，使用const也可以但是不推荐。

  

template <int N>

struct Factorial {

static const int value;

};

  

template <int N>

const int Factorial<N>::value = N * Factorial<N - 1>::value;

  

template <>

const int Factorial<0>::value = 1;

def ({ 一堆函数内容； x ；}) 那么宏返回值就是x

[分享]GCC online documentation - GNU Project

#define G_DEBUG(...) do { \

printf("File: %s, Function: %s,Line: %d have Error\n", __FILE__, **func** , __LINE__); \

printf(__VA_ARGS__); \

} while(0)

[分享]https://zhuanlan.zhihu.com/p/678312465

循环嵌套应当遵循外小内大的原则，这是由于cache缓存比内存读取要快，因此大块的连续数据最适合放在内层由cache缓存好

[分享]http://ifeve.com/wp-content/uploads/2013/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8BV1.0.pdf

  

3/5法则，在C++的类实现中，应当实现3:基本构造和析构，拷贝构造(深拷贝)，赋值构造(浅拷贝)，5就是在3的基础上增加move语义和移动构造

临时对象是右值

[分享]Linux系统编程_~宪宪的博客-CSDN博客

GNU的套件中有objcopy 可以用来优化可执行文件的调试信息，将其分离并在需要的时候连接回去

objdump 可以查看符号表 -t和汇编 -d

ccache (gcc) ,ccache 是一种缓存软件，他可以缓存中间产物.o 以此加快下次重复编译的效率


enum class name ： uint8 {enum1，enum2}； 这是C++11引入的新枚举，具有更严格的类型检查，并且允许你定义他的基础数据类型，而且具有像类一样的作用空间，不会造成同名冲突，在对该数据检查的时候，必须进行强制类型转换 static_cast<int>（value）

  

-> . 访问符优先级高于&，-> . 访问符本身优先级相同，从左到右结合

int main(int argc, char *argv[], char *envp[])

  

  

代码的坏味道：预编译时期 ## 会替换并链接字符，假如此时的字符和某些变量或是类型同名，也会被视为标识符，而不是错误的链接到变量/类型处。尽量使用有差异的宏参数传入，避免和枚举成员同名

CJSON的字符串输出是需要手动释放内存的，创建json字符串和解析字符串都要del 根节点

find / -name "文件名" 在根目录开始递归搜索该文件

当S是2的幂 ，用S取余(取模)，等价于&（S-1），垓方式仅针对S是2的幂适用

前向声明就是在定义前直接声明 例如 class A； FUNC（）{内部有A} class A实现 ，此时func内部不能访问class元素 因为前向声明只保证编译实现，其访问细节此时仍不可见，一般在模板定义时使用，前向声明只适合数据类型(结构体 类 联合体 枚举) 不适合变量

动态库关键字_ 返回值 函数名 (形参) {}

  

尽可能避免在宏函数中使用宏作为参数，推荐使用#ifdef 语句1 #else 语句1的参数修改版 #endif来实现

#ifdef USE_DEF

memcpy(dest,src,5);

#else

memcpy(dest,src,15);

#endif

  

/*实际上 printf也是宏函数*/

using namea = int;

using classa = A;

typename是和模板绑定的，用于在模板声明和模板类内来给模板参数取别名

typedef 可以在 全局 /类内/命名空间内 使用，加入在类内使用了typedef ，使用的时候也要 classname::TYPENAME

[分享]https://codeload.github.com/gcc-mirror/gcc/zip/refs/heads/master

引用叠加原则，当对一个对象双层引用 有&则&，全&&则&&；&&是右值引用，右值引用旨在避免无意义的拷贝 多用于数据转移，

以下是按照相关性进行的分类：



https://github.com/jwasham/coding-interview-university?tab=readme-ov-file

https://wangdoc.com/bash/grammar

  

pipe(int [2]); [0]是读 [1]是写端，这是无名管道 只能用于父子或者兄弟进程

有名管道 mkfifo（char* filename，mode）；然后就可以打开这个文件，fd = open（name，权限）； 然后对这个fd操作读写就可以了 ，可以在任意进程通信，一般一个使用只读，一个使用只写打开该管道文件

fd2 = dup（fd）；操作fd2 等同操作 fd；这是对原文件符号的重定向

fd2 = dup2（fd2，fd1）；这是对文件内容的重定向，将会把fd1的操作 通过fd2显示出来

int new_fd = fcntl(int old_fd, int cmd, int fd_no); cmd固定为F_DUPFD， 等同于dup（），理论上来说 也可以实现dup2，但是测试发现实际无效的

mmap和munmap需要包含<mman.h>, void* p= mmap（NULL,文件大小，读写权限，共享/私有（不会影响实际文件）权限，fd，偏移量(一般是0)），p是映射指针

要求mmap的读写权限<= 打开fd对应文件时候的权限

munmap（p，长度）

打开文件并映射到mmap之后就可以关闭fd文件了

文件必须有内容，长度>0，否则会错误，可以使用lseek（fd，正偏移，SEEK_END）；然后write（fd，‘0’，1）；来拓展文件大小

或者truncate（文件名，大小）；/ftruncate（fd，大小）；

truncate实际上是改变了整个文件大小，如果offset小于原大小就是截断，反之是拓展

一般对mmap使用共享写入之后要使用msync函数来同步文件，(等同于cmd sync)

#include <sys/mman.h>

int msync(void *addr, size_t length, int flags);

addr：指向内存映射区域的起始地址，通常是 mmap 函数返回的地址。

length：需要同步的字节长度，一般是映射区域的长度。

flags：同步标志，有以下几种选项：

MS_ASYNC：异步地将映射区域中的修改写回到文件中。这意味着 msync 调用会立即返回，而将写操作交给内核在后台完成。

MS_SYNC：同步地将映射区域中的修改写回到文件中。msync 会等待直到修改被完全写回文件。

MS_INVALIDATE：使内存映射区域中的数据失效，下一次访问该区域时会从文件中重新读取。

-fvisibility=hidden 对于直接编译和编译.a库可以减少符号表进而减少编译大小，同时不会影响调用，但是.so 隐藏则会无法正常调用

对于__attribute__((设置内容)) 一般放在函数或者变量头，且只需要 在声明处使用即可

<dlfcn.h> 需要-ldl连接dl库，其中包含的函数主要是为了动态加载 可以不链接的情况下 加载动态库，dlopen，dlclose，dlsym（获取函数）

-Wl（小写l），rpath=库路径（可以使用相对路径）

这样可以把链接库的目录也编译进程序里，而不需要修改环境变量

C++11支持类的成员默认值，perf是一款linux性能分析工具

objdump -p 可执行文件 可以查看该文件链接的库

readelf -d 可执行文件 也可以查看

gcc

--sysroot=/opt/fsl-imx-x11/4.1.15-2.0.0/sysroots/cortexa7hf-neon-poky-linux-gnueabi

-march=armv7ve

-mfpu=neon

-mfloat-abi=hard

-mcpu=cortex-a7

  

--sysroot 指定标准库路径，而非本机标准库路径，这是交叉编译必选项

-march 目标架构

-mfpu 浮点单元

-mfloat-abi 浮点单元类型

-mcpu 硬件型号

  

strip工具去除的是unused和debug符号 也可以使用objcopy分别去除这两个

  

__attribute__((aligned(4))) 用于起始地址对齐 并不会改变结构体内部对齐方式

准确来说是 pack 会影响最小对齐(比如内部无填充)，尽管attribute不会影响内部填充，但是单对齐大于结构体实际大小的时候，会使得他的大小扩充到对齐数值，譬如大小为12的结构体使用__attribute__((aligned(16))) 那么sizeof 的结果就是16了

  

使用qt目录下的mingw(不带tools的那个)里面有个windeployqt.exe 可执行程序名 即可将缺失的dll复制到项目目录 以解决clion编译后运行异常退出的问题(是因为缺少某些库)

  

  

CppGuide社区

https://cppguide.cn/

C++那些事

https://light-city.github.io/#google_vignette


