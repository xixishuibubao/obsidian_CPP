## 1. 原生结构

### 1.1 位域 `struct` :

	:数字
	表示占用多少个bit位，从低位开始算。  
	该结构常用于保存多种状态以节约内存。
	若位域有剩余未显式声明占用的位，会被系统自动填充。
	也可以匿名的占用位置。

```c++

typedef struct {
    uint8_t bit0 : 1;
    uint8_t bit1 : 1;
    uint8_t bit2 : 1;
    uint8_t : 1;
    uint8_t bit4 : 1;
    uint8_t bit5 : 1;
    uint8_t bit6 : 1;
    uint8_t bit7 : 1;
    uint8_t bit8_15 : 8;
} bit_t;

/*
结构体初始化不能在函数外直接对成员用等号赋值
val.member= ？；要用 struct val =｛.member = ？｝；
*/
譬如
static int arr[10];

typedef struct
{
    int* arrdata;
}s;

s s1={.arrdata = arr};
/*或者这样*/
int main(void){
    s1.arrdata=arr;
}
```

### 1.2 联合体`Union`

```c++
/* 大小可以不一致，以较大的成员大小为准 */
typedef union {
    uint8_t str[2];
    uint32_t num;
}MyStr_t;
```

### 1.3 复杂基础类型

	  union联合体访问的时候可以先访问外部名，再访问内部元素
	以便于结构清晰（尽管可以直接访问联合体内部 而不通过联合体名，
	但不利于结构清晰。 如下是一个全程访问的实例：

```c++
#include <stdint.h>

typedef struct {
    uint8_t id;
    union {
        uint8_t status;
        struct {
            uint8_t status1 : 1;
            uint8_t status2 : 1;
            uint8_t status3 : 1;
            uint8_t status4 : 1;
            uint8_t status5 : 1;
            uint8_t status6 : 1;
            uint8_t status7 : 1;
        } every_status;
    } u_allstatus;
} userdata_t;

int main(int argc, char* argv[])
{
    userdata_t data；
    data.u_allstatus.every_status.status1 = 1;
}
```

### 1.4 内存对齐
	
对于`union struct`来说

`union`联合的内存对齐和占用有类似结构体的规则。
1. 当联合体内部大小不一致时，首先union的大小至少是最大元素的大小。
2. 若使用默认对齐原则，则会查看union是否是最大数据类型,和结构体
   一样，最终对齐是最大元素的整数倍。

- 使用`#pragma pack(1)`后，会进行强制对齐，不添加空的填充字节。



## 2. `<string.h>`库

### 2.1 通用规范

1. `<string.h>`系列的函数基本内部都不包含对空指针的处理，传入`NULL`会导致程序异常。 
2. `char[]`字符类型,一定注意末尾`\0`问题，无`\0`会越界。


### 2.2 常用函数

```C++
/* 获取字符串长度，依赖\0判断结尾 */
/* sizeof 获取的是占用字节数，数组作为形参传递会退化为指针 */
int len = strlen(const char* str);
/* 获取子字符串指针 */
char* p = strstr(const char* allstr,const char* substrings);
/* 字符串复制 */
strcpy(char* dest,const char* src);
/* 字符比较 ,return 0 则相同*/
int res = strcmp(const char* , const char*);

/* 内存复制 */
memcpy(void* dest,const void*,size_t size);
/* 内存填充 */
memset(void* dest,int c,size_t size);
/* 内存比较 ,return 0;则相同*/
int res = memcmp(const void*,const void*,size_t size);
```

## 3. 指针与内存

### 3.1 `malloc` & `free`

```C++
/* 申请失败返回 NULL */
#include <stdlib.h>
void* p  =  malloc(size_t size);
/* 释放申请的堆内存，只能free动态内存，否则会异常。 */
/* 重复free(p)也会导致异常 */
free(p);
```

### 3.2 指针步长

	指针类型可以做差得到的是步长的个数，而非数值差，
    步长 = 指针指向的数据类型大小，
    想要求地址差，要先转化为为 void* 再求差 


```C++

int main(int argc, char* argv[])
{
    void* p1 = (void*)0x00000000;
    void* p2 = (void*)0x00000008;
    int res1 = p2 - p1;/* 8byte */
    int res2 = (int*)p2 -(int*)p1;/* 2 */
    int res3 = (double*)p2 -(double*)p1; /* 1 */
    return 0;
}
```

### 3.3 函数指针

  结构体的成员变量(函数指针类型）（通过函数指针注册的）,
其在外部的实现也可以是静态，通过结构体访问其成员并不是直接调用函数，
而是指针访问，所以被声明为static的函数也可以被外部文件调用。


## 4. 编译与宏

### 4.1 编译器保留宏


1. `__FILE__`：当前源代码文件名。
2. `__LINE__`：当前源代码文件中的行号。
3. `__DATE__`：源代码文件被编译的日期。
4. `__TIME__`：源代码文件被编译的时间。
5. `__func__`：（C99起）当前函数的名称。
6. `__STDC__`：如果编译器遵循ANSI C标准，则定义为1。
7. `__cplusplus`：如果编译器支持C++，则定义为一个表示C++版本的值。
8. `__FUNCTION__`: 当前函数名，C++更友好，输出更详细，`__func__`是为了兼容C。
9. `__VA_ARGS__`: 可变参数列表


### 4.2 编译关键字

```c++

#ifdef 
#elif
#endif

#if
#else
#endif

#define
#undef

#error
#warning
```
`#if defined(A_DEF)` 等价于` #ifdef A_DEF`

`#pragma pack(show)`  显示当前内存对齐的字节数，编辑器默认8字节对齐
`#pragma pack(n)`       设置编辑器按照n个字节对齐，n可以取值1,2,4,8,16
`#pragma pack(push)`  将当前的对齐字节数压入栈顶，不改变对齐字节数
`#pragma pack(push,n)` 将当前的对齐字节数压入栈顶，并按照n字节对齐
`#pragma pack(pop)`    弹出栈顶对齐字节数，不改变对齐字节数
`#pragma pack(pop,n)` 弹出栈顶并直接丢弃，按照n字节对齐

demo:
`#pragma pack(1)` 以下内容按照1字节对齐
`#pragma pack(0)` 恢复默认对齐



### 4.3 常用宏
`##`拼接标识符
- 宏定义每次只能展开一级，所以有嵌套的情况下要定义一个中间宏。
- 宏优先展开外层。
```c++
#define CAST(A,B)    A##B
#define         X         i_
#define         Y         have
#define   _CAST(A,B)      A##B
#define    CAST(A,B)    _CAST(A,B)
```

  自定打印格式接口宏:
```C++
#define MyPrintf(format,...) do{printf("[%s_%d_%s] : ",__FILE__, \
__LINE__,__FUNCTION__); \
printf(format,##__VA_ARGS__);}while(0)
```

`#` 是串化标志符号

```C++
#define STRING(x)   #x
```

- 调用 `STRING(abc)`会产生字符串，等价于`"abc"`。
- 直接在宏使用`"abc"`,引号里的内容是不可变的。
- 字符串常量可以直接拼接，`"ABC""DEF"`和`"ABCDEF"`是等价的。
- `#`串化以后的内容不能与`##`直接相连，`##`本身就可以连接标识符。

### 4.4 可变参数函数

  - `typeof`的参数不能多重括号，实现自己的可变参数的函数时要注意。
  - `va_list`等是宏定义不是函数，`va_arg`就利用了`typeof`;


```C++
#include <stdarg.h>
void my_printf(const char* format, ...) {
    va_list args;           /* 定义可变参数列表 */
    va_start(args, format); /* 初始化，指向第一个可变参数 */
    while(*format) {
        if(*format != '%') {
            putchar(*format++); /* 输出普通字符*/
            continue;
        }
    }
    format++; /* 跳过 % */
    switch(*format++) {
        case 'd': { /* 整数int*/
            num = va_arg(args, int);
            printf("%d", num);
            break;
        }
        case 's': { /* 字符串 */
            char* str = va_arg(args, char*);
            printf("%s", str ? str : "(null)");
            break;
        }
        case 'f': { /* 浮点数（注意：可变参数会自动提升为 double）*/
            double f = va_arg(args, double);
            printf("%.2f", f); /* 保留两位小数 */
            break;
        }

        default:
            putchar('%');           /* 输出未识别的 % 符号 */
            putchar(*(format - 1)); /* 回退显示格式字符*/
            break;
    }
    va_end(args); /* 清理可变参数列表*/
}
```

### 4.5 闭包

- `{}`是独立语句块的边界。
- `()`是表达式的边界。
- 可以通过在`{}`外加`()`的方式使得宏变得具有返回值。
  闭包表达式的返回值是最后一个内容。

```c++
#define RETURN_MACRO(x) ({ x; })

int main(int argc,char* argv[])
{ int a =RETURN_MACRO(5); /* a = 5；*/ }
```

### 4.6 宏的作用域

  - `#define`具有类似静态全局的特性，他的作用域是定义和包含他的文件。
  - 在函数中定义宏和在函数外定义。作用域都是整个文件。
  - 如果后续不想使用应当使用`#undef`来取消宏定义的生效。



## 5. 操作符与关键字

### 5.1 `*++p`

- `*`和`++`优先级是同一个等级的，遵循右优先性。

1. `++*p` 先访问指针，再自增该指针指向的数据。
2. `*p++` 先自增一个步长的指针，再访问原指针。
3. `*++p` 先自增一个步长指针，再访问自增后的指针指向的数据。
### 5.2 `[] () *`

- 优先级`() > [] > *`

1. `int* arr[5]`        一个元素为`int*`的`arr`数组，元素数量5
2. `int (*arr)[5]`       一个指针，其指向 `int[5]`，实际上就是二维数组的行指针
3. `int (*arr)[2][3]`    一个指针,指向`int[2][3]`,实际上就是三维数组的Z指针
4. `int (*arr[2])[3]`    一个指针数组，每个指针都指向为`int[3]`

### 5.3 `const`

1. *对于确定不修改的形参，尤其是指针，加上`const`传递，
2. 返回值若非必要，不要加`const`

```c++
int func(const char*);
```

### 5.4 `volatile

- 连续调用同一变量，可能会为了优化，从缓存(寄存器)直接读取，而非去内存读取。
- 可能导致无法读取到最新的值，譬如硬件单元的寄存器数据，应当用`volatile`修饰。

```C++
const volatile int* p = (const volatile int*)(a_addr);
```

### 5.5 `extern`

- `extern` 使得修饰的函数或变量具有外链性质。

1. 非静态函数本身就具有外链接性，不使用`extern`也可以实现外部链接。
2. 外链的变量在外部文件使用必须使用`extern`声明，并且要和原型一致。
    不可将数组外链声明为指针，反之亦然。
3. `extern`的变量，在编译但未链接时，表现为`.o`文件符号表中的一个未定义的引用。
    在链接阶段再被重定向到正确的位置。

### 5.6 switch

  `switch_case`标签特性:
  - `switch case`中，`case:`具有标签属性（类似`goto`的标签），
  - 最好对每个标签内容加`{}`使其变成局部内容，不然在标签后声明变量会报错。
  
  - 因为`case`块不是函数，只是一个流程节点，不能定义内容，必须在`{}`内或者`switch case`外才可以定义。


## 6. 代码技法

### 6.1 常见技巧

1. 许多编译器只识别31字符之前的名字，所以无论是变量还是函数名都
   应当保持在3-31字节的范围，以便于审查。

2. pp代表指针的指针前缀，h代表句柄前缀，任务应使用task函数名。

3. 函数名以特定标识（所属功能组）+名词+动词命名
   使用`unix`风格，缩进量使用空格，只使用`\n` 尽可能避免使用`\r\n`。

4. 所有变量使用前必须初始化,尤其是未定义行为的指针初始化`NULL`；
   局部变量总是定义在使用处附近，而非函数体头部。

5. 返回值类型与函数名换行标识，这是一种写法，风格统一就好。
```C++
	void 
	func(void);
```

6. 避免使用逗号，定义多个变量。

7. `if`和`else`的内部嵌套不应该超过两层，如有必要使用函数调用来封装或者
   使用`switch`和`case`，以减少复杂性和清晰逻辑。

8. 在不影响实现的前提下，短句应当放在函数体头部，尽量使函数长句在靠后的位置。

9. `switch`中的`case`要和`break`对齐缩进，保证一定有`default`，每个`case`应当都有
   对应的`break`。

10. 避免使用“魔法数字”，使用宏定义来封装，以清晰逻辑。

11. 不可被赋值的内容应当放置在判断语句的左侧，以避免`==`和`=`的混淆。

### 6.2 比较浮点

- 浮点数不能直接判断等，一般求差然后＜一定范围。

1. `abs`是绝对值函数(整形)
2. `fabsf`是浮点绝对值
```c++
#include <math.h>
int main(void) {
    float a   = 1.3f;
    float b   = 1.2f;
    float sub = fabsf(a - b);
    if(sub < 0.001f) {
        printf("a is near b");
    }
}
```

### 6.3 `,`表达式

- 在使用逗号的时候，最终结果是以最后一个内容为准的。

```c++
int main() {
    int a = 1;
    int b = 2;
    int c = (a, b); /* 结果是2 */
}
```

### 6.4 函数设计

1. 使用`const`修饰形参。
2. 高频函数可以内联 `static inline`。
3. 内部要对`NULL`,和异常值做处理。
4. 形参最好不要超过四个
    - `ARM32` 使用`AAPCS`调用约定，使用`R0-R3`寄存器传参，
        超出部分压栈。
    - `ARM64` 使用前8寄存器传参，超出部分压栈。
    - `X86_32` 使用`cdecl`调用约定，所有参数压栈，从右向左压栈。
    - `X86_64` 使用前6寄存器传递参数，超出部分压栈。
5. 使用结构体封装多个数据，并以指针传递。
6. 单一出口，`do{ break; } while(0);`实现单一出口。
7. `switch` 代替多重`if`。
8. 嵌套循环，大循环在内层。
9. if语句将更高概率的选项放在前面。
10. 递归函数优先使用尾递归。
11. 最小惊讶原则:显式传递，避免过多使用全局变量。
12. 避免魔法数字，使用枚举来提高可读性和类型安全
13. 避免超大函数，使用小函数来分割大函数。

### 6.5 指针特性

- 字符串本质就是指针，`[]`是索引访问,可以这么访问。

- `int arr[10];` `arr[5]`等价于 `*(&arr[0]+5)`。
- 同理可以写成`5[arr]`,其实本质上都是指针访问，基地址+偏移。
- 相当于直接取字符串索引位置字符，

```c++
char itoc(int index) { return "0123456789abcdef"[index]; }
```

### 6.6 运算优化

- 位运算效率比乘除法要高。

1. 乘除2的幂，转化位移位；
2. 对2的幂取余，可以转化&，
     `x % (2^y) == x & (2^y -1);`
     一般编译器会帮你优化这个。
3. 按位取反 ， 异或`0XFF`（全1）是一样的结果，
   大部分时候效率相当，一些平台上异或会更快。
    
4. 异或`(^)`: 异或就是相反则为1，^0是本身，^1是取反。
   一个数异或自己一定是0，可以利用这种特性，查找重复出现数字。



### 6.7 位图排序

- 位图排序，使用`bit`位或者数组代表有或者无。
- 每次读取到数据就丢进位图。
- 扫描位图，对应位置`>=1`就存入新数组，最后就是顺序排列。


### 6.8 `__attribute__`

- `__attribute__(())`是gcc的功能，给代码加上属性。
- `__attribute__`代表强制属性（不同编译器的该命令可能不同，但大体相似）

1. 函数自动初始化（在main之前运行）:
    `void func(void)__attribute__(constructor(5));`
    `constructor(5)`，`constructor`使其在`main`前运行。
    (5)是优先级，数字越小，优先级越高，越早调用。
2. 弱定义函数，`attribute((weak))void func(void) { }`
   - 无其他同名函数则使用这个，有则使用非弱定义的。
   - 无强定义，但有多个弱定义同名函数结果是未知的。


## 7. 基础概念

### 7.1 栈

#### 7.1.1 栈的概念

1. 栈遵循先入后出的原则。
2. 栈是逆向生长的，即栈底在高地址，栈顶在低地址。
    - 一般栈起始边界在编译完成后就被确定，他紧挨着静态区，在静态区后开始分配。
    - 当栈溢出后，可能发生越界访问导致未定义行为，譬如侵入到堆区或静态区。
    - 在未知的情况下修改了其他变量。
3. 一个函数定义的局部变量过多可能就会导致栈溢出，
   - 但只是对指针指向的数据进行访问和修改是不占用栈大小的，
   - 多使用指针，尤其是使用结构体指针避免传入一个过大的实体。
4. 函数的执行依赖于栈的存储，其中函数调用相关的存储单元是栈帧。
   - 栈帧包含了函数形参的实体，函数内的局部变量，函数返回地址(返回到哪个栈帧，该栈帧的指针)。
5. 栈的占用动态的，当调用完一个函数之后，该栈会被销毁。所以避免栈溢出设定栈大小的主要因素是：
	- 主函数main调用的单个函数栈大小和局部变量大小。
	- 形参个数（假设形参都尽可能以指针传递了）。


#### 7.1.2 栈帧
- 栈帧记录了函数的必要数据，也是函数被调用时的栈开销。
- 栈开销本身是不包括他调用的其他函数的栈帧的，总的栈开销是同一时刻在运行的函数所有栈帧相加。

```C++
int main(int argc,char* argv[]) {
    pfunc1();
    pfunc3();
}
void pfunc1(void) { pfunc2(); }
/*
栈帧开销过程如下：
<1> 为main分配栈帧，此时栈占用最小，此时栈占用为main栈。
<2> 为pfunc1分配栈帧（此时还未执行到pfunc2），此时栈占用为main栈+pfunc1栈。
<3> pfunc2被调用，为pfunc2分配栈，此时栈占用为main栈+pfunc1栈+pfunc2栈。
<4> pfunc2调用结束，返回到pfunc1，pfunc2栈帧销毁，此时栈占用为main栈+pfunc1栈
<5> pfunc1调用结束，return了，pfunc1栈帧销毁，此时栈占用为main栈
<6> 为pfunc3分配栈帧，此时栈占用为main栈+pfunc3栈
<7> pfunc3调用结束，销毁pfunc3栈帧， 此时栈占用为main栈
<8> main结束，所有栈帧销毁。
*/
```

## 7.2 调用约定

### 7.2.1 平台差异

```Markdown
### **跨平台调用约定细则对比表**
| **架构/场景**       | **调用约定**       | **参数传递**                          | **可变参数支持** | **栈清理者** | **关键说明（含修正/兼容性）**                                                                 |
|---------------------|--------------------|---------------------------------------|------------------|--------------|----------------------------------------------------------------------------------------|
| **ARM32 (AAPCS)**   | 标准AAPCS          | R0-R3（前4寄存器）+ 栈（右→左，8字节对齐） | ✅ 原生支持      | **调用者**   | 调用者需手动清栈（`add sp, N`），栈需8字节对齐；常用于嵌入式场景                          |
| **X86-32 (cdecl)**  | `__cdecl`          | 全栈（右→左压栈）                      | ✅ 原生支持      | **调用者**   | C语言默认，调用者执行`add esp, N`；支持`printf`等可变参数函数                                |
| **X86-32 (stdcall)**| `__stdcall`        | 全栈（右→左压栈）                      | ❌ 不支持        | **被调用者** | **DLL导出专用**，被调用者`ret N`清栈；名字改编含参数总字节（如`_Func@8`），禁止可变参数          |
| **ARM64 (Aarch64)** | Aarch64 ABI        | X0-X7（前8寄存器）+ 栈（右→左，16字节对齐） | ✅ 原生支持      | **被调用者** | 被调用者隐式清栈（`ret`自动对齐栈），支持`printf`（格式字符串在X0，参数寄存器传递）               |
| **x86-64-WIN**      | `__fastcall`       | RCX/RDX（前2寄存器）+ 栈（右→左压栈）    | ❌ 不支持        | **被调用者** | **模拟stdcall兼容性**：被调用者`ret N`清栈（类似X86-32），但前2参数走寄存器；禁止可变参数（无法遍历寄存器） |
| **X86-64-Linux**    | System V ABI       | RDI-RSI-RDX-RCX-R8-R9（前6寄存器）+ 栈    | ✅ 原生支持      | **被调用者** | 被调用者隐式清栈（`ret`自动处理），支持`printf`（格式字符串在RDI，后续参数寄存器/栈混合传递）       |
| **C语言默认**       | `cdecl`（跨平台）  | 全栈（右→左压栈）                      | ✅ 原生支持      | **调用者**   | **语义强制**：无论平台，调用者必须清栈（如GCC在x86-64仍生成`add rsp, N`，覆盖System V ABI的被调清栈） |
| **x86-64 兼容性**   | `__fastcall` → `stdcall` | 寄存器→全栈映射                         | -                | -            | **二进制兼容底层**：Win64通过WoW64模拟X86-32的stdcall（被调清栈），编译器自动转换寄存器/栈传参     |


### **表格关键说明（修正与补充）**
1. **参数传递细节**：
    - ARM32 前4参数寄存器（R0-R3），ARM64 前8参数寄存器（X0-X7），X86-64-Linux 前6参数寄存器（RDI-RSI-RDX-RCX-R8-R9）。
    - x86-64-WIN `__fastcall` 仅前2参数寄存器（RCX/RDX），后续全栈，与 X86-32 `stdcall` 的全栈设计形成**调用栈布局兼容**（便于WoW64模拟）。

2. **栈清理者的“语义 vs 实现”**：
    - C语言`cdecl` **强制调用者清栈**（语言层规则），但平台可能通过寄存器优化参数传递（如Linux x86-64），但调用者仍需清栈（包括寄存器传参的字节）。
    - x86-64-WIN `__fastcall` 虽被调清栈（`ret N`），但通过编译器封装，对上层C语言代码呈现“类似`stdcall`的兼容性”（被调清栈语义）。

3. **可变参数限制的本质**：
    - `stdcall`/`__fastcall` 被调清栈**禁止可变参数**，因被调用者无法通过栈遍历参数数量（无格式字符串寄存器）。
    - ARM64/Aarch64 支持可变参数是因**格式字符串固定在X0寄存器**，被调用者可通过寄存器遍历参数（如`printf`的X0指向格式字符串，X1-X7取寄存器参数，栈取后续参数）。

4. **x86-64 兼容性设计**：
    - Windows 通过`__fastcall` 的**被调清栈**（`ret N`）模拟 X86-32 `stdcall` 的行为，确保 DLL 导出符号的二进制兼容（如WoW64自动映射`_Func@8`到64位的`ret 8`）。
    - Linux 的 System V ABI 被调清栈与 C语言`cdecl` 调用者清栈**表面冲突**，但 GCC 通过生成`add rsp, N` 覆盖 ABI 规则，严格遵循 C 语言语义。
```

### 7.2.2 简单速记

```markdown
### **跨平台调用约定核心差异表**
| **架构/约定**       | **栈清理者**   | **参数传递方式**                | **可变参数支持** | **关键说明（匹配您的总结）**                                                                 |
|---------------------|----------------|---------------------------------|------------------|----------------------------------------------------------------------------------------|
| **32位原生约定**     |                |                                 |                  |                                                                                        |
| `cdecl`  | **调用者**     | 全栈（无寄存器）                | ✅ 支持          | 32位C语言默认，调用者`add esp, N`清栈（如`printf`）                                       |
| `stdcall`| **被调用者**   | 全栈（无寄存器）                | ❌ 不支持        | **仅32位DLL导出**，被调用者`ret N`清栈，因无法遍历参数禁止可变参数                         |
| **64位及Win32导出**  |                |                                 |                  |                                                                                        |
| ARM64    | **被调用者**   | 8寄存器（X0-X7）+ 栈            | ✅ 支持          | 被调清栈，但格式字符串固定X0寄存器，可遍历参数（如`printf`）                               |
| x86-64-WIN fastcall | **被调用者** | 2寄存器（RCX/RDX）+ 栈          | ❌ 不支持        | **模拟Win32 stdcall兼容性**，被调`ret N`清栈，前2参数寄存器，禁止可变参数（无寄存器遍历）    |
| x86-64-Linux | **被调用者**  | 6寄存器（RDI-RSI-RDX-RCX-R8-R9）+ 栈 | ✅ 支持      | 被调清栈，但格式字符串在RDI寄存器，可遍历参数（如`printf`）                               |
| **特殊约定特性**     |                |                                 |                  |                                                                                        |
| `cdecl`  | 调用者（全平台）| **全栈（无寄存器）**            | ✅ 支持          | 唯一全栈无寄存器的可变参数约定（C语言强制语义）                                           |
| `stdcall`| 被调用者（仅32位）| **全栈（无寄存器）**            | ❌ 不支持        | 唯一全栈无寄存器的不可变参数约定（DLL导出专用）                                           |
| ARM32 AAPCS | 调用者       | 4寄存器（R0-R3）+ 栈            | ✅ 支持          | 32位中唯一寄存器传参的调用者清栈约定（嵌入式常用）                                         |
```

- 只有32位原生的约定是调用者清理栈的，64位以及`win32`的`stdcall`导出都是被调清栈的。
    
- 只有`cdecl`和`stdcall`是无寄存器传参的，`arm32/64`分别是4/8寄存器，`X86-64`,`win`是2寄存器，`linux`是6寄存器传参。
    
- 只有`stdcall`和`fastcall`不支持可变参数。