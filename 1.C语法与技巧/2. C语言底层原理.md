## 1. 编译与链接

### 1.1 链接器与符号表

符号表有三类符号：
- 全局
- 外部`extern`
- 局部,对外的不可见性`static`

  

### 1.2 链接器与变量/函数定义

- 链接器发现有多个强定义就会报错
    
- 强定义：函数名，初始化的变量
    
- 弱定义：未初始化的非静态全局变量
    

- 当强弱定义同时存在，强定义会覆盖弱定义。
    
- 当多个弱定义同时存在，以哪个为准是不定的。
    

  

### 1.3 与链接相关编码规范

为了避免多定义的隐藏问题(此类问题不会编译报错)。

1. 尽量避免使用全局变量
    
2. 全局变量使用`static`修饰
    
3. 外部变量使用`extern`
    

  

## 2. 程序启动

### 2.1 程序启动过程

1. `./a`(假设a是可执行程序)
    
2. 首先`fork()`一个进程
    
3. 然后传递`argc` `envp`给`execve()`函数
    
4. `execve()`调用加载器
    
5. 加载器将可执行程序的头表信息加载并建立磁盘到内存的映射，拉起启动流
    
6. `_libc_init_first`->`_init->atexit`
   (这些是系统对C可执行程序的初始化和 必要调用流程)
    
7. `main`(这里才是我们的`main`)->`_exit()`(调用结束退出)
    

### 2.2 后台启动和堆栈分析

- `./a.out & `使程序后台运行并返回他的`pid`的值
- `cat /proc/pid的值/maps`可以看到在执行程序的信息（物理地址和堆栈）
    

## 3. 调试工具

### 3.1 objdump

#### 3.1.1 简单指令汇总

- `objdump -s`(16进制显示)
    
- `-d` (反汇编显示)
    
- `-h`(查看各段内存分布)
    
- `-r`(查看需要重定位的内容) 某个.o文件
    

### 3.2 readelf

#### 3.2.1 简单指令汇总

- `readelf -h 某个.o` 查看某个.o文件程序头信息
    
- `-s` 查看符号表
    

  

  注：`VMA` 虚拟内存地址，`LMA` 加载内存地址，

  `V virtual`, `M memory`, `A address`, `L load`

  

## 4. 自定程序入口函数

### 4.1 自定义入口函数

- 要在自定程序内部使用`_exit()`;[在`<unistd.h>`里]
    
- `gcc -nostartfiles -e 函数名 -o 目标文件名称 依赖的.o/.c`