# 1.常用工具

## 1.1 keil5

### 1.1.1 常见报错

- 无对应的`unicode`映射字符:
	- keil工程编译无错误，但是界面有X提示，对应的描述为无可用的`unicode`字符映射，是因为中文路径，更换路径后恢复正常。

### 1.1.2 反汇编debug

1. 使用keil生成反汇编,`fromelf --text -a -c --output name.dis name.axf`。
	1. 其中`axf`名字要和实际保持一致，另外就是`axf`要放在主目录下或
      使用`.\`使得能正确访问到文件。
2. 生成bin文件,`fromelf.exe --bin -o "$L@L.bin" "#L"`。
3. 生成dis文件，`fromelf.exe --text -a -c -o "$L@L.dis" "#L"`。
4. 未重定义使用`printf`，可能运行出现断点，同时会调用 `sys_write`，`sys_open`卡死。

## 1.2 JFlash

### 1.2.1 查看halt异常

1. `j-flash-commander`调试查看汇编，来定位定位死机异常。依次输入
    1. `usb`
    2. `halt`
    3. 芯片型号
    4. 接口类型
    5. `savebin e:/ram.bin 0x20000000 0x10000`
    6. 意思是导出`bin`文件，保存在e盘符下，开始地址为`0x20000000`，大小为`0x10000`。
       
2. 查看`SP`指针,内容指向的是保存了进入异常时的`R0`寄存器内容的地址。
	1. `sp`指向位置保存的内容依次是`R0,R1,R2,R3,R12,LR,PC,XPRS`的内容（地址依次增加）共计8个数据，32个字节。
	2. 在此之后是函数的内存栈，里面存着当时的函数栈的使用数据。
	3. 可以在比较靠前的位置找到`LR`寄存器的值，是当时进入函数时分配的返回地址。
	4. 通过`LR`的值去向前回溯，可以找到调用者函数，调用处会将返回地址也就是`LR`寄存器的值先入栈，随后是局部变量的分配等等。

### 1.2.2 异常快照

- halt硬件异常中断与堆栈分析原理:
	1. 在进入halt前，cpu会把当前的`PC,LR,R12,R3,R2,R1,R0`依次入栈，由于栈的逆向生长结构，实际上SP指向栈的内容，从低地址到高地址依次是`R0,R1,R2,R3,R12,LR,PC`。
	2. 这些是特殊寄存器，在调用函数时就会更新他们的值。把他们入栈是为了保护现场，便于完成函数或者中断后切回。
	3. 当进入halt时，`PC`寄存器里的内容是进入中断前的函数，`LR`则是调用该函数的函数，因为`PC`寄存器在调用一个函数以后，他始终保存调用的子函数调用地址，直到该函数结束返回。

### 1.2.3 相关寄存器

- 寄存器与`thumb`模式:
	1. 寄存器含义
		- `R0`是返回值寄存器
		- `LR`是返回地址寄存器
		- `PC`是当前执行代码地址 ,以汇编语句地址为单位
		- `SP`是栈顶
		- `R0-R3`,四个通用寄存器一般用来保存形参
		- `R4-R11`,用来保存局部变量
		- `R12`是在子程序间`scratch`寄存器，也称为`ip`寄存器
		- `R13/SP`栈顶指针寄存器
		- `R14/LR`链接寄存器，也称返回地址寄存器
		- `R15/PC`运行函数寄存器。
	2. `LR`返回弹入`PC`时，和实际地址差1，地址末位被用作指令集指示位。
	3. 因为`thumb`指令的标识就是末尾为1，但是实际地址末尾是0。
	4. 因为M内核没有ARM模式，所以`LR`内地址总是以1结尾，`PC`内地址总是以0结尾。
	
- `R0-R3`和`R12`都可以用来保存返回值和传递参数。
	- `R1-R11`被称为保留寄存器，当使用保留寄存器时，要对其进行入栈进行保存，返回时出栈还原。
- 中断时会依次将`XPSR,PC,LR,R12,R3-R0`入栈。如果有需要也要将`R11-R4`入栈，在RTOS中，会在`pendsv`中断时，先入栈`XPSR,PC,LR,R12,R3-R0`，再入栈`R11-R4`，这符合`AAPCS`标准寄存器栈帧的规定。
    
# 2.简单汇编

## 2.1 `br,b,ldr,str.bx`

1. `BL`跳转入
2. `B`循环
3. `LDR`加载内容到寄存器
4. `STR`读取寄存器内容到
5. `[R4]`对`R4`存的值作为指针使用，访问并操作其指向内容
6. `BX LR`,将`LR`寄存器压入`PC`并跳转
7. `B`无条件跳转，一般用于死循环
---

- 汇编指令操作的是地址,譬如你有一个变量`a`，要实现`a=5;`
	1. 如果有偏移量这里要用`=a+offset`。
	   加载`a`的地址，相当于`r0=&a`；
	   `LDR R0,a`  
	   
	2.  将`5`保存在`R1`，相当于`r1=5`；`#`代表立即数
	   `MOV R1,#5`
	   
	3. 将`R1`的值给到`R0`地址的指向位置上，相当于`*r0 = r1`；
	   `STR R1,[R0]`
	   
---
- `bx lr` ,不是直接跳转到`lr`，而是先根据标准栈帧规定，将寄存器值从栈弹出，然后再访问弹出的`LR`,这也是实现`pendsv`切换任务的基础。
  ```markdown
		低地址    --->     高地址
	    r0-r3  r12  lr  pc   xpsr
	```

# 3.存储与boot

## 3.1 存储特性

- 常见的存储为 `eeprom`和`flash`
	1. `eeprom`一般支持字操作（擦写）
	2. `flash`不支持字操作
	3. MCU内部一般是`norflash`
	   
- `norflash`只能以页为擦写单位，所以用户数据这类经常变动的数据适合使用`eeprom`，而一些备份数据由于不变动，则适合写入`flash`。
  
- `bootloader`一般是挂载在内部`flash`的，文件系统一般是挂载在外部内存上的（譬如SD卡）。

## 3.2 合并烧录

- boot与app合并烧录:
	1. 首先在keil设置好app和boot的偏移，使用keil生成hex。
	2. 使用notepaad++打开文件，将boot末尾的结束字节删除，直接把app的`bin`加在后面，最后补上一个结束符。
     
- 如下、手动合并boot和app的`.hex`文件:
	 1. 设置boot程序下载到flash的开头地址为`0x08000000`，然后编译程序生成`hex`文件。
	 2. 设置APP程序下载到flash的开头地址，然后编译程序生成`hex`文件。
	 3. 用 notepad++ 打开 boot 的`hex`文件和APP的`hex`文件
 　　　　把boot的`.hex`最后一句结束语句去掉(删除`00000001FF`)
 　　　　把APP的`.hex`全部内容拷贝复制到 刚才删掉结束语句的boot的`.hex`后面。
	 4. 把两个`hex`合成的`hex`文件重新命名为`XXX.hex`，然后通过烧写工具烧写到`0x0800 0000` 开始位置的地址即可。