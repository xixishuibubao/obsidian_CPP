# 1.变量

1. `shell`变量命名规则类似C语言，但是在定义时不允许使用空格，且无类型标识符。
2. `string="hello world"` ,定义了一个`string`变量内容为`hello world`。
3. `echo ${string}`,`echo`是输出的意思，使用变量的时候需要加`$`和`{}`。
4. `echo $(pwd)`,输出当前目录到控制台。
5. `#`代表注释。
6. `unset` 删除已定义的变量。
7. `readonly`该变量为只读变量。
8. `#!`是声明解释器位置的关键字，`#!/bin/sh`, `linux`使用`/bin/sh`下的`bash`。
9. `declare -i my_value=42`,`declare`类似`gcc`中的`attribute`，代表属性。`-i`声明为整型变量。
10. `echo -e $val`,`-e`的作用是输出时，将转义字符正确输出，不加`-e`按照普通字符输出。
11. `" "`和`' '`作用类似，但`' '`输出时，内容中不可以有变量，`" "`支持输出中有变量和转义字符。
12. 多行注释,使用`：'` 加`内容` 加`` ' ``来进行多行注释。
	- ```bash
	  	  : '
		  	  这是注释的部分。可以有多行内容。
	  	  ' 
	  ```

13. 环境变量(全局变量)需要前加`export`修饰：
	- demo: `export MY_VAR="hello"`。
	- 可以先定义再修饰， `MY_VAR="hello"; export MY_VAR;`。
	- `local`局部的，`readonly`只读的。

# 2.变量传参

1. 基础传参
   - `$#` 传参个数
   - `$0`文件名
   - `$1`第一个参数,`$2`第二个参数,同理`$n` 
2. `$*`以一个单字符串显示所有向脚本传递的参数。
3. `$*`遇到传递的参数用`" "`括起来的情况,以`"$1 $2 … $n"`的形式输出所有参数。
4. `$@`遇到传递的参数用`" "`括起来的情况,以`"$1" "$2" "…" "$n"`的形式输出所有参数。
5. `$$`脚本运行的当前进程`ID`
6. `$!`后台运行的最后一个进程的`ID`
7. `$@`与`$*`的两种情况都相同
8. `$-`显示`Shell`使用的当前选项，与`set`命令功能相同。 
9. `$?`显示最后命令的退出状态。`0`表示没有错误，其他任何值表明有错误。
10. `;`分号是分隔符，无实际意义，用 `\`代替也一样的。

# 3.数组

1. `my_arr=(1 2 3);`,使用这样的方式声明数组。
2. `declare -A my_arr`,`declare`可以换成`typeset`，如果不先`-A`则变成了内容替换，不论`[ ]`中是什么，都只会输出最后一次赋值的内容。
   - ```bash
		my_arr["name"]="John"
		my_arr["age"]=30
		my_arr[777]=okk #此时仍旧可以使用数字角标
     ```

1. 使用`declare -A`关联修饰了一个数组，这个数组可以表现出哈希索引的性质，通过特定的关键字做为索引，查找内容，使用该方式前需要使用`#!/bin/sh`。标明`sh`解释器位置，并且如果是`windows`下编程需要使用`notepad++`或`vscode`。将换行格式从`win`格式`CR LF，\r\n`转为`unix`格式`LF，\n`，否则换行就会报错。
2. `declare -A site=(["a"]="typea" ["b"]="typeb" ["c"]="typec");`,可以定义的时候就初始化，也可以先定义，再添加内容，shell的数组有点类似`C++`的`string`，大小是动态的，不必一开始就给定大小。
3. `arr[@]`和`[*]`是一样的，代表获取全部元素。
4. `!arr[@]`和`!arr[*]`,在前面加上! 代表获取全部索引。
5. `#arr[@]`和`#arr[*]`,在前面加上`#`代表获取元素个数 ，如果`*`和`@`替换成具体的索引，则代表获取该元素的长度。

# 4.基本运算符

1. `+-*/%` ，使用`` `expr a + b - c` ``的形式，注意前后要有`` ` ` ``(反引号)。内容和操作符之间要加`空格`，乘法`*`要使用转义字符`\*`,而`+ - /`正常。除法会取整，小数操作可能无结果。
2. `==`和`!=`也可以使用,但要在`[ ]`内，如`if [ ${a} == ${b} ]`,各个符号之间要空格。
3. 关系运算符，基本要求跟`==` `!=`一样，各成员之间要空格。
   - `-eq`检测两个数是否相等，相等返回 `true`。`[ $a -eq $b ]`,`equal` 相等。
   - `-ne`检测两个数是否不相等，不相等返回`true`。`[ $a -ne $b ]`,`not equal`不相等。
   - `-gt`检测左边的数是否大于右边的，是则返回`true`。`[ $a -gt $b ]`,`greater than`大于。
   - `-lt`检测左边的数是否小于右边的，是则返回`true`。`[ $a -lt $b ]`,`less than`小于。
   - `-ge`检测左边的数是否大于等于右边的，是则返回`true`。`[ $a -ge $b ]`,`gt and eq`大于等于。
   - `-le`检测左边的数是否小于等于右边的，是则返回`true`。`[ $a -le $b ]`,`ls and eq`小于等于。
4. 布尔运算符，各成员之间要空格。
	- `！`非 `if [ $a != $b ]`
	- `-o`或`[ $a -lt 20 -o $b -gt 100 ]`,`or`或者
	- `-a`与`[ $a -lt 20 -a $b -gt 100 ]`,`and`与
	- 不要试图在布尔运算的多个表达式之间对单个加上`" "`或者`' '`,这会使加了的式子一直为`true` 
	- 
5. `&&`逻辑与,`||`逻辑或,要在`[[]]`两层方括号之间使用，如`[[ $a -lt 10 && $b -lt 5 ]]`。
6. 字符串运算符:
	- `=`检测两个字符串是否相等，相等返回`true`。 `[ $a = $b ]`
	- `!=`检测两个字符串是否不相等，不相等返回`true`。 `[ $a != $b ]`
	- `-z`检测字符串长度是否为0，为0返回`true`。`[ -z $a ]` `zero` 零 
	- `-n`检测字符串长度是否不为 0，不为0返回`true`。 `[ -n "$a" ]`,`no`不为0
	- `$`检测字符串是否不为空，不为空返回`true` 。`[[ $a ]]`这里要用`[[ ]]`,而不是单`[ ]`
7. 文件测试符
	- `-b file`检测文件是否是块设备文件，`[ -b $file ]` 
	- `-c file`检测文件是否是字符设备文件，`[ -c $file ]`
	- `-d file`检测文件是否是目录，`[ -d $file ]`
	- `-f file`检测文件是否是普通文件，非目录和设备文件，`[ -f $file ]`
	- `-g file`检测文件是否设置了`SGID`位，`[ -g $file ]`
	- `-k file`检测文件是否设置了粘着位`Sticky Bit`，`[ -k $file ]`
	- `-p file`检测文件是否是有名管道`[ -p $file ]`
	- `-u file`检测文件是否设置了`SUID`位，`[ -u $file ]`
	- `-r file`检测文件是否可读`[ -r $file ]`
	- `-w file`检测文件是否可写`[ -w $file ]`
	- `-x file`检测文件是否可执行，`[ -x $file ]`
	- `-s file`检测文件是否为空,文件大小是否大于0，`[ -s $file ]`
	- `-e file`检测文件（包括目录）是否存在,`[ -e $file ]`
	  
	- `-S`:判断某文件是否`socket`
	- `-L` 检测文件是否存在并且是一个符号链接


8. 自增和自减要使用`let`，如`let val++`和`let val--`,这里的变量是不需要加`$`的。 
9. `$(( ))`算数运算符，`num=$((num + 1))`等价与`let num++`。
10. `expr` ,`num=$(expr $num + 1))`等价`let num++`。
11. `(())` ,`((num++))`等价`let num++`。

# 5.`echo`输出

1. `echo -e " \" "`,使用`-e`配合`" "`,将转义字符转义输出。
2. `echo '\"' `,使用`` ` ` ``,将转义字符视为普通符号输出。
3. ``echo `date`;``,输出时间,`;`只是分隔符,无实际作用。
4. `echo "It is a test" > myfile`,重定向输出目标，这会替换源文件内容。
	- `echo xxx >>filename`,这是追加写入内容到文件。
	- `2>>filename`和`2>filename`重定向错误内容到文件。
	- `0 1 2`分别对应着：标准输入，标准输出，错误输出。
5. `&>filename`重定向全部内容到文件。
6. `` `linuxcmd` ``,使用`` ` ` ``包围`linux`指令可以使用其输出内容。
    
# 6.printf

1. 语法和C中相同，但是不需要括号。

# 7.通配符
1. `*`全字符
2. `?`单字符
3. `[abc]`匹配`[ ]`内的任意字符,也可`[a-z]`范围内匹配单字符。
4. `{ }`有点类似`&`与的意思,`file{1,2,3}`,代表`file1`和`file2`和`file3`。