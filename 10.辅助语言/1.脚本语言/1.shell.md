# 1.变量

1. `shell`变量命名规则类似C语言，但是在定义时不允许使用空格，且无类型标识符。
2. `string="hello world"` ,定义了一个`string`变量内容为`hello world`。
3. `echo ${string}`,`echo`是输出的意思，使用变量的时候需要加`$`和`{}`。
4. `echo $(pwd)`,输出当前目录到控制台。
5. `#`代表注释。
6. `unset` 删除已定义的变量。
7. `readonly`该变量为只读变量。
8. `#!`是声明解释器位置的关键字，`#!/bin/sh`, `linux`使用`/bin/sh`下的`bash`。
9. `declare -i my_value=42`,`declare`类似`gcc`中的`attribute`，代表属性。`-i`声明为整型变量。
10. `echo -e $val`,`-e`的作用是输出时，将转义字符正确输出，不加`-e`按照普通字符输出。
11. `" "`和`' '`作用类似，但`' '`输出时，内容中不可以有变量，`" "`支持输出中有变量和转义字符。
12. 多行注释 : '这是注释的部分。可以有多行内容。' 使用： + ' + 内容 + '来进行多行注释
13. 环境变量(可以理解为全局变量) 需要前加export修饰，譬如export MY_VAR="hello"

也可以先定义再修饰，譬如 MY_VAR="hello"; export MY_VAR;
local局部的，readonly只读的，

# 2.变量传参

1. 基础传参
   - `$#` 传参个数
   - `$0`文件名
   - `$1`第一个参数,`$2`第二个参数,同理`$n` 
2. `$*`以一个单字符串显示所有向脚本传递的参数。
3. `$*`遇到传递的参数用`" "`括起来的情况,以`"$1 $2 … $n"`的形式输出所有参数。
4. `$$`脚本运行的当前进程`ID`
5. `$!`后台运行的最后一个进程的`ID`
6. `$@`与`$*`的两种情况都相同
7. `$-`显示`Shell`使用的当前选项，与`set`命令功能相同。 
8. `$?`显示最后命令的退出状态。`0`表示没有错误，其他任何值表明有错误。
9. `;`分号是分隔符，无实际意义，用 `\`代替也一样的。

# 3.数组

1. `my_arr=(1 2 3);`,使用这样的方式声明数组。
2. `declare -A my_arr`,`declare`可以换成`typeset`，如果不先`-A`则变成了内容替换，不论`[ ]`中是什么，都只会输出最后一次赋值的内容。
   - ```bash
		my_arr["name"]="John"
		my_arr["age"]=30
		my_arr[777]=okk #此时仍旧可以使用数字角标
     ```

1. 使用`declare -A`关联修饰了一个数组，这个数组可以表现出哈希索引的性质，通过特定的关键字做为索引，查找内容，使用该方式前需要使用`#!/bin/sh`。标明`sh`解释器位置，并且如果是`windows`下编程需要使用`notepad++`或`vscode`。将换行格式从`win`格式`CR LF，\r\n`转为`unix`格式`LF，\n`，否则换行就会报错。
2. `declare -A site=(["a"]="typea" ["b"]="typeb" ["c"]="typec");`,可以定义的时候就初始化，也可以先定义，再添加内容，shell的数组有点类似`C++`的`string`，大小是动态的，不必一开始就给定大小。
3. `arr[@]`和`[_]`是一样的，代表获取全部元素。

* <5>!arr[@]和!arr[*] 在前面加上! 代表获取全部索引值

<6>#arr[@]和#arr[*] 在前面加上# 代表获取元素个数 ，如果*和@替换成具体的索引，

则代表获取该元素的长度

  

4.基础语法之基本运算符：

<1>加减乘除 取余 ，使用`expr a + b - c`的形式，注意前后要有反引号(波浪线键)，

这里需要注意，要在内容和操作符之间要加空格，乘法*要使用转义字符\* 而+ - /正常，.

除法会取整，小数操作可能无结果。

<2> == 和 ！= 也可以使用但是要在[]内，譬如 if [ ${a} == ${b} ],各个符号之间要空格。

<3>关系运算符，基本要求跟== !=一样，各成员之间要空格，

-eq 检测两个数是否相等，相等返回 true。[ $a -eq $b ] equal 相等

-ne 检测两个数是否不相等，不相等返回 true。[ $a -ne $b ] not equal 不相等

-gt 检测左边的数是否大于右边的，如果是，则返回 true。[ $a -gt $b ] greater than 大于

-lt 检测左边的数是否小于右边的，如果是，则返回 true。[ $a -lt $b ] less than 小于

-ge 检测左边的数是否大于等于右边的，如果是，则返回 true。[ $a -ge $b ]gt and eq >=

-le 检测左边的数是否小于等于右边的，如果是，则返回 true。[ $a -le $b ]ls and eq <=

<4>布尔运算符，各成员之间要空格。

！非 if [ $a != $b ]

-o或 [ $a -lt 20 -o $b -gt 100 ] or或者

-a与 [ $a -lt 20 -a $b -gt 100 ] and与

不要试图在布尔运算的多个表达式之间对单个加上"" 或者'' 这会使加了的式子一直为true <5>&&逻辑与 ||逻辑或,要在[[]]两层方括号之间使用，如[[ $a -lt 10 && $b -lt 5 ]]

<6>字符串运算符:

= 检测两个字符串是否相等，相等返回 true。 [ $a = $b ]

!= 检测两个字符串是否不相等，不相等返回 true。 [ $a != $b ]

-z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] zero 零 -n 检测字符串长度是否不为 0，不为 0 返回 true。 [ -n "$a" ] no 不为0

$ 检测字符串是否不为空，不为空返回 true。 [[ $a ]] 这里要用双[[]],而不是单[]

<7>文件测试符

-b file 检测文件是否是块设备文件，[ -b $file ] -c file 检测文件是否是字符设备文件，[ -c $file ]

-d file 检测文件是否是目录，[ -d $file ] -f file 检测文件是否是普通文件（既不是目录，也不是设备文件）[ -f $file ]

-g file 检测文件是否设置了 SGID 位，[ -g $file ] -k file 检测文件是否设置了粘着位(Sticky Bit)，[ -k $file ]

-p file 检测文件是否是有名管道[ -p $file ] -u file 检测文件是否设置了 SUID 位，[ -u $file ]

-r file 检测文件是否可读[ -r $file ] -w file 检测文件是否可写[ -w $file ]

-x file 检测文件是否可执行，[ -x $file ] -s file 检测文件是否为空（文件大小是否大于0），[ -s $file ]

-e file 检测文件（包括目录）是否存在，[ -e $file ] 其他检查符： -S: 判断某文件是否 socket。 -L: 检测文件是否存在并且是一个符号链接。 <8>自增，自减要使用let，如 let val++ 这里的变量是不需要加$的， let val--

<9>$(( ))算数运算符，如num=$((num + 1)) 等价与let num++

<10>expr ,如num=$(expr $num + 1)) 等价与let num++

<11>(()) ,如((num++)) 等价与let num++

  

5.基础语法之echo：

<1>将转义字符转义输出 echo -e " \" " 使用-e 双引号

<2>将转义字符视为普通符号输出 echo '\"' 使用单引号

<3>输出时间 echo `date`; 输出时间 ;只是分隔符 不会进行任何操作

<4>重定向输出目标，echo "It is a test" > myfile,这会替换源文件内容,

echo >> 这是追加写入

<5> 2>> 2>重定向错误内容

<6>&>重定向全部内容到

6.基础语法之printf：

<1>语法和C中相同，但是不需要括号

<2>

  

通配符：

*全字符 ? 单字符 [abc]匹配[]内的任意字符 也可以[a-z]范围内匹配单字符

{}有点类似 &与 的意思 file{1,2,3} 代表file1和file2和file3