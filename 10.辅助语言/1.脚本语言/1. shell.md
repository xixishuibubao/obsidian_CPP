# 1. 变量

1. `shell`变量命名规则类似C语言，但是在定义时不允许使用空格，且无类型标识符。
2. `string="hello world"` ,定义了一个`string`变量内容为`hello world`。
3. `echo ${string}`,`echo`是输出的意思，使用变量的时候需要加`$`和`{}`。
4. `echo $(pwd)`,输出当前目录到控制台。
5. `#`代表注释。
6. `unset` 删除已定义的变量。
7. `readonly`该变量为只读变量。
8. `#!`是声明解释器位置的关键字，`#!/bin/sh`, `linux`使用`/bin/sh`下的`bash`。
9. `declare -i my_value=42`,`declare`类似`gcc`中的`attribute`，代表属性。`-i`声明为整型变量。
10. `echo -e $val`,`-e`的作用是输出时，将转义字符正确输出，不加`-e`按照普通字符输出。
11. `" "`和`' '`作用类似，但`' '`输出时，内容中不可以有变量，`" "`支持输出中有变量和转义字符。
12. 多行注释,使用`：'` 加`内容` 加`` ' ``来进行多行注释。
	- ```bash
	  	  : '
		  	  这是注释的部分。可以有多行内容。
	  	  ' 
	  ```

13. 环境变量(全局变量)需要前加`export`修饰：
	- demo: `export MY_VAR="hello"`。
	- 可以先定义再修饰， `MY_VAR="hello"; export MY_VAR;`。
	- `local`局部的，`readonly`只读的。

# 2. 变量传参

1. 基础传参
   - `$#` 传参个数
   - `$0`文件名
   - `$1`第一个参数,`$2`第二个参数,同理`$n` 
2. `$*`以一个单字符串显示所有向脚本传递的参数。
3. `$*`遇到传递的参数用`" "`括起来的情况,以`"$1 $2 … $n"`的形式输出所有参数。
4. `$@`遇到传递的参数用`" "`括起来的情况,以`"$1" "$2" "…" "$n"`的形式输出所有参数。
5. `$$`脚本运行的当前进程`ID`
6. `$!`后台运行的最后一个进程的`ID`
7. `$-`显示`Shell`使用的当前选项，与`set`命令功能相同。 
8. `$?`显示最后命令的退出状态。`0`表示没有错误，其他任何值表明有错误。
9. `;`分号是分隔符，无实际意义，用 `\`代替也一样的。

# 3. 数组

1. `my_arr=(1 2 3);`,使用这样的方式声明数组。
2. `declare -A my_arr`,`declare`可以换成`typeset`，如果不先`-A`则变成了内容替换，不论`[ ]`中是什么，都只会输出最后一次赋值的内容。
   - ```bash
		my_arr["name"]="John"
		my_arr["age"]=30
		my_arr[777]=okk #此时仍旧可以使用数字角标
     ```

1. 使用`declare -A`关联修饰了一个数组，这个数组可以表现出哈希索引的性质，通过特定的关键字做为索引，查找内容，使用该方式前需要使用`#!/bin/sh`。标明`sh`解释器位置，并且如果是`windows`下编程需要使用`notepad++`或`vscode`。将换行格式从`win`格式`CR LF，\r\n`转为`unix`格式`LF，\n`，否则换行就会报错。
2. `declare -A site=(["a"]="typea" ["b"]="typeb" ["c"]="typec");`,可以定义的时候就初始化，也可以先定义，再添加内容，shell的数组有点类似`C++`的`string`，大小是动态的，不必一开始就给定大小。
3. `arr[@]`和`[*]`是一样的，代表获取全部元素。
4. `!arr[@]`和`!arr[*]`,在前面加上! 代表获取全部索引。
5. `#arr[@]`和`#arr[*]`,在前面加上`#`代表获取元素个数 ，如果`*`和`@`替换成具体的索引，则代表获取该元素的长度。

# 4. 基本运算符

1. `+-*/%` ，使用`` `expr a + b - c` ``的形式，注意前后要有`` ` ` ``(反引号)。内容和操作符之间要加`空格`，乘法`*`要使用转义字符`\*`,而`+ - /`正常。除法会取整，小数操作可能无结果。
2. `==`和`!=`也可以使用,但要在`[ ]`内，如`if [ ${a} == ${b} ]`,各个符号之间要空格。
3. 关系运算符，基本要求跟`==` `!=`一样，各成员之间要空格。
   - `-eq`检测两个数是否相等，相等返回 `true`。`[ $a -eq $b ]`,`equal` 相等。
   - `-ne`检测两个数是否不相等，不相等返回`true`。`[ $a -ne $b ]`,`not equal`不相等。
   - `-gt`检测左边的数是否大于右边的，是则返回`true`。`[ $a -gt $b ]`,`greater than`大于。
   - `-lt`检测左边的数是否小于右边的，是则返回`true`。`[ $a -lt $b ]`,`less than`小于。
   - `-ge`检测左边的数是否大于等于右边的，是则返回`true`。`[ $a -ge $b ]`,`gt and eq`大于等于。
   - `-le`检测左边的数是否小于等于右边的，是则返回`true`。`[ $a -le $b ]`,`ls and eq`小于等于。
4. 布尔运算符，各成员之间要空格。
	- `！`非 `if [ $a != $b ]`
	- `-o`或`[ $a -lt 20 -o $b -gt 100 ]`,`or`或者
	- `-a`与`[ $a -lt 20 -a $b -gt 100 ]`,`and`与
	- 不要试图在布尔运算的多个表达式之间对单个加上`" "`或者`' '`,这会使加了的式子一直为`true` 
	- 
5. `&&`逻辑与,`||`逻辑或,要在`[[]]`两层方括号之间使用，如`[[ $a -lt 10 && $b -lt 5 ]]`。
6. 字符串运算符:
	- `=`检测两个字符串是否相等，相等返回`true`。 `[ $a = $b ]`
	- `!=`检测两个字符串是否不相等，不相等返回`true`。 `[ $a != $b ]`
	- `-z`检测字符串长度是否为0，为0返回`true`。`[ -z $a ]` `zero` 零 
	- `-n`检测字符串长度是否不为 0，不为0返回`true`。 `[ -n "$a" ]`,`no`不为0
	- `$`检测字符串是否不为空，不为空返回`true` 。`[[ $a ]]`这里要用`[[ ]]`,而不是单`[ ]`
7. 文件测试符
	- `-b file`检测文件是否是块设备文件，`[ -b $file ]` 
	- `-c file`检测文件是否是字符设备文件，`[ -c $file ]`
	- `-d file`检测文件是否是目录，`[ -d $file ]`
	- `-f file`检测文件是否是普通文件，非目录和设备文件，`[ -f $file ]`
	- `-g file`检测文件是否设置了`SGID`位，`[ -g $file ]`
	- `-k file`检测文件是否设置了粘着位`Sticky Bit`，`[ -k $file ]`
	- `-p file`检测文件是否是有名管道`[ -p $file ]`
	- `-u file`检测文件是否设置了`SUID`位，`[ -u $file ]`
	- `-r file`检测文件是否可读`[ -r $file ]`
	- `-w file`检测文件是否可写`[ -w $file ]`
	- `-x file`检测文件是否可执行，`[ -x $file ]`
	- `-s file`检测文件是否为空,文件大小是否大于0，`[ -s $file ]`
	- `-e file`检测文件（包括目录）是否存在,`[ -e $file ]`
	  
	- `-S`:判断某文件是否`socket`
	- `-L` 检测文件是否存在并且是一个符号链接


8. 自增和自减要使用`let`，如`let val++`和`let val--`,这里的变量是不需要加`$`的。 
9. `$(( ))`算数运算符，`num=$((num + 1))`等价与`let num++`。
10. `expr` ,`num=$(expr $num + 1))`等价`let num++`。
11. `(())` ,`((num++))`等价`let num++`。
12. `$[ ]`用于`[ ]`内的整数数学运算`+-*/`，`n=5;echo $[$n+1];`,换成`${}`或`$()`都会报错。

# 5. `echo`输出

1. `echo -e " \" "`,使用`-e`配合`" "`,将转义字符转义输出。
2. `echo '\"' `,使用`` ` ` ``,将转义字符视为普通符号输出。
3. ``echo `date`;``,输出时间,`;`只是分隔符,无实际作用。
4. `echo "It is a test" > myfile`,重定向输出目标，这会替换源文件内容。
	- `echo xxx >>filename`,这是追加写入内容到文件。
	- `2>>filename`和`2>filename`重定向错误内容到文件。
	- `0 1 2`分别对应着：标准输入，标准输出，错误输出。
5. `&>filename`重定向全部内容到文件。
6. `` `linuxcmd` ``,使用`` ` ` ``包围`linux`指令可以使用其输出内容。
    
# 6. printf
1. 语法和C中相同，但是不需要括号。

# 7. 通配符
1. `*`全字符
2. `?`单字符
3. `[abc]`匹配`[ ]`内的任意字符,也可`[a-z]`范围内匹配单字符。
4. `{ }`有点类似`&`与的意思,`file{1,2,3}`,代表`file1`和`file2`和`file3`。


# 8. `${ }`与`$( )`
1. `${ }`用于变量拓展，并且可以嵌套,`${ }`中放命令是不会执行的。例：`echo ${my_value};`
2. `$( )`用于命令替换，会执行命令并保留其输出值。例：`echo $(pwd);`

# 9.  `test`语句

- **任何命令执行退出后都有结果码，`$?`会存储其值，为`0`成功，其他为失败。**


1. `test`语句可以直接判断一个表达式的结果是真还是假，也可以用`[ 表达式 ]`代替，表达式前后要和`[ ]`有空格。
2. `[[  ]]`内可以使用通配符，`[[ "tom" = [Tt]?? ]];echo $?;`比较`"tom"`是否是`T`或`t`开头的三字符，输出`0`。

# 10. `if`语句
- `if`一定要以`fi`结尾，结构与`C++`的条件语句类似。
1. 格式如下：
	- ```bash
		#bash
		  if expr1; then
			  func1;
		elif expr2; then
			func2;
		else
			: #空执行
		fi
		# then之后不能加；并且如果分支中有空执行要用: 不可以什么都不写
	  ```
# 11. `case`语句
- `case`一定要用`esac`结尾，且格式与`C++`类似。
1. 格式如下：
	- ```bash
		  #bash
		  case expr in 
		  a)
			  cmda
			  ;; # ；；用来跳出case分支
		 b)
			 cmdb
			 ;;
		*) #可以用通配符，比如* [efg] 之类，也可以用或 |
			cmdx
			;;
		esac
	  
	  ```
	
# 12. 循环
- `break`跳出循环。
1. ```bash
	   #for循环,列表支持通配符 * [Aa]之类的
	   for val in 1 2 3; do #这里的 1 2 3 是一个列表，每次循环会使得val = 列表中的一个值
		   echo $val;
	   done
	   ```
2. ```bash
	   #for循环 C风格
	   for(( i = 1; i <= 5; i++ ));do
		   echo $i;
	   done
	   ```
3. ```bash
		#while循环，条件为真，$?为0时进行循环
		# 逐行读取 mymuduo 日志，提取错误信息（含 ERROR 关键字的行）
		log_file="mymuduo.log"
		while read -r line; do  # read -r 读取一行，不转义特殊字符
		if echo $line | grep -q "ERROR"; then  # 筛选 ERROR 行
			echo "❌ 错误日志：$line"
		fi
		done < $log_file  # < $log_file 表示从文件读取，而非键盘输入,不加 <$log_file 表示从键盘输入读取
	   ```
4. ```bash
	   # 条件为假则循环
	   log_file="mymuduo_start.log" 
	   timeout=30 # 超时时间 30 秒 
	   count=0 # 直到文件存在，或超时 
	   until [ -f $log_file ] || [ $count -ge $timeout ]; do 
	   echo "⌛ 等待日志文件生成...（已等待 $count 秒）" 
	   sleep 1 
	   count=$((count + 1)) 
	   done    
	   ```
5. ```bash
	   #select常配合case使用，再对应选项后输入break，避免循环选择
	   select 变量 in 选项1 选项2 选项3...; do 
	   cmd
	   break # 可选：选择后退出循环；不写则持续让用户选择 
	   done
	   ```

# 13. 函数
1. ```bash
	   function_name( ) {
		   local local_val; #函数内的局部变量，外部不可访问。
		   return number;
	   }

	   function_name arg0 arg1 ...
	   ```
2. `${ }`字符操作：
	1. `${#var}`,返回字符串变量 var 的长度。
	2. `${#var:m}`,返回`${var}`中从第`m+1`个字符到最后的部分。
	3. `${var:m:len}`,返回`${var}`中从第`m+1`个字符开始，长度为`len`的部分。
	4. `${var#pattern}`,删除`${var}`中开头部分与`pattern`匹配的**最小部分**。
	5. `${var##pattern}`,删除`${var}`中开头部分与`pattern`匹配的**最大部分**。
	6. `${var%pattern}`,删除`${var}`中结尾部分与`pattern`匹配的**最小部分**。
	7. `${var%%pattern}`,删除`${var}`中结尾部分与`pattern`匹配的**最大部分**。
	8. `${var/old/new}`,用`new`替换`${var}`中**第一次**出现的`old`。
	9. `${var//old/new}`,用`new`替换`${var}`中所有的`old`(**全局替换**)。
3. 内置命令：
	1. `trap`,用来绑定**函数**或**命令行**与信号。
		- ```bash
		  trap "响应命令/函数" 信号1 信号2 ...
			  ```
	- 常见信号：
		- |   |   |   |   
|---|---|---|
|1|SIGHUP|终端断开（如 SSH 连接断开）|
|2|SIGINT|键盘中断（Ctrl+C）|
|3|SIGQUIT|键盘退出（Ctrl+\）|
|9|SIGKILL|强制终止（`kill -9 进程号`）|
|15|SIGTERM|正常终止（`kill 进程号`，默认信号）|
|0|（无名称）|脚本正常退出（执行到末尾 /`exit`）|


# 14. `sed`和`awk` 流处理工具
1. `sed [选项] 命令 文件名`, 处理文件
	1. `-i`,直接修改原文件（默认只输出结果，不改原文件）选项
	2. `-n`,静默模式，只输出被处理的行（默认输出所有行）选项
	3. `-e`,执行多个 sed 命令（多命令拼接）选项
	4. `s/old/new/g`,替换命令（`s=substitute`，`g=global` 全局替换）
	5. `/内容/xxx`,先匹配特定内容的行，然后再执行什么操作。
	6. `" "`和`' '`包裹命令的区别，`" "`可以使用外部的shell变量和命令，不需要转义。
	   而`' '`内只当做字符处理(可以正则)，另外这两种情况下`/`都要转义为`\/`。
2. `awk`
	1. `awk '条件 { 动作 }' 文件名`,
		1. 每行文本按分隔符分割后的 “列”，用 `$n` 表示（`$1`= 第 1 列，`$2`= 第 2 列...）
		2. `$0`表示整行文本，`awk '{print $0}' log.txt`（打印所有行）
	2. `awk -F '分隔符' '条件 { 动作 }' 文件名`
		1. `-F`指定字段分隔符（如 `-F ','` 按逗号分割 CSV 文件，`awk -F ':' '{print $1}' /etc/passwd`（提取用户名）
		2. 条件是可选的，满足条件才执行动作，如 `/ERROR/` 匹配含 ERROR 的行，`awk '/ERROR/ {print $0}' log.txt`|
		3. 动作是必选，如 `print`打印、`count++`计数，`awk '{print $1,$3}' log.txt`
		4. 内置变量 `NR`（行号）、`NF`（当前行字段数）、`FILENAME`（文件名），`awk '{print NR":"$0}' log.txt`（打印行号 + 内容）
3. 分隔符`/`
	1. `sed`和`awk`使用`/`作为命令中的标识符，是因为`/`代表正则的匹配模式，传承自unix风格，也可以用`@` `#`等代替但是不能混用，代替主要是因为要使用的内容包含了`/`需要转义比较多。
	2. `sed '/error/s@https://@http://@g' file`