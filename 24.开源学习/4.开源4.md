  


### **一、极简** **STL** **实现：tinystl（C++，8000 行）**

#### **项目定位**：模仿 C++11 STL 的玩具库，聚焦容器/算法实现

#### **核心学习点**：

- **数据结构**：`vector` 的动态扩容（1.5倍 vs 2倍策略）、`list` 的双向链表实现
    
- **迭代器**：`iterator_traits` 的编译期类型萃取
    
- **内存****管理**：`alloc` 适配器与 `construct/destroy` 封装
    
- **学习资源**：
    
    - GitHub 注释版：[icyross/tinystl](https://github.com/icyross/tinystl)（逐文件注释，对比原生 STL）
        
    - 知乎专栏：[tinystl 源码剖析：从 vector 到 map](https://zhuanlan.zhihu.com/p/353245374)（解析 `unordered_map` 的哈希冲突处理）
        
- **代码量**：~8000 行（含测试），单文件编译友好
    
- **适合场景**：理解 STL 底层实现，避免被标准库封装隐藏的细节
    

  

  

### **二、玩具级 Linux 内核：linux-0.11（C，1.5万行）**

#### **项目定位**：1991 年 Linux 内核初版，实现进程调度/内存管理

#### **核心学习点**：

- **启动流程**：实模式 → 保护模式切换（`head.s` 汇编）
    
- **进程管理**：`fork` 的写时复制（COW）雏形（`copy_process`）
    
- **内存****管理**：固定大小内存块分配（`mem_map` 数组）
    
- **学习资源**：
    
    - 书籍《Linux 内核完全注释》（第二版）：逐行解析 0.11 内核，附启动盘制作教程
        
    - 在线模拟器：[os.phil-opp.com/linux-0.11](https://os.phil-opp.com/linux-0.11/)（浏览器运行内核，调试 `printk`）
        
- **代码量**：~1.5 万行（含汇编），模块高度内聚
    
- **适合场景**：理解内核设计哲学，比 Linux 5.x 更易上手
    

  

  

### **三、轻量级协程库：libco（C，5000 行，腾讯开源）**

#### **项目定位**：Nginx 风格的用户态协程，单线程支持 10 万级并发

#### **核心学习点**：

- **上下文切换**：`ucontext` 封装（`coctx_swap` 汇编实现）
    
- **调度器**：`co_eventloop` 的事件驱动 + 协程队列
    
- **同步原语**：`co_mutex` 的无锁等待队列（CAS 实现）
    
- **学习资源**：
    
    - GitHub 注释版：[Tencent/libco](https://github.com/Tencent/libco)（`coctx_make` 上下文创建解析）
        
    - 博客：[libco 源码剖析：从协程创建到调度](https://segmentfault.com/a/1190000015739349)（对比 Go 协程调度）
        
- **代码量**：~5000 行（核心 `co_core.c` 仅 1500 行）
    
- **适合场景**：掌握用户态线程设计，理解 Nginx 高性能的底层逻辑
    

  

  

### **四、HTTP 解析器：http-parser（C，1200 行，Node.js 同款）**

#### **项目定位**：纯 C 的 HTTP 请求/响应解析器，零依赖

#### **核心学习点**：

- **状态机**：`http_parser` 的 32 种状态转换（请求行 → 头部 → 正文）
    
- **零拷贝**：`http_parser_parse_url` 的 URL 组件提取（指针偏移，不复制数据）
    
- **错误处理**：`http_parser_init` 的协议容错（忽略非法空格、大小写）
    
- **学习资源**：
    
    - 官方文档：[github.com/nodejs/http-parser](https://github.com/nodejs/http-parser)（含性能测试对比）
        
    - 知乎文章：[http-parser 源码解析：如何 1ms 解析 1000 个 HTTP 请求](https://zhuanlan.zhihu.com/p/432157893)（分析 `on_headers_complete` 回调机制）
        
- **代码量**：~1200 行（单文件 `http_parser.c`）
    
- **适合场景**：学习协议解析状态机，实现自定义 Web 服务器
    

  

  

### **五、极简 JSON 解析器：cJSON（C，1200 行）**

#### **项目定位**：纯 C 的 JSON 编解码器，支持任意嵌套结构

#### **核心学习点**：

- **数据结构**：`cJSON` 节点的双向链表（`next/prev` 指针）
    
- **解析流程**：`cJSON_Parse` 的递归下降解析（处理对象/数组）
    
- **内存管理**：`cJSON_Malloc` 与 `cJSON_Free` 的配套实现
    
- **学习资源**：
    
    - 中文教程：[cJSON 源码剖析与实践](https://www.cnblogs.com/skynet/p/3560367.html)（解析 `cJSON_Print` 的格式化输出）
        
    - 测试用例：GitHub 仓库（[DaveGamble/cJSON](https://github.com/DaveGamble/cJSON)）的 `test.c` 覆盖边界条件
        
- **代码量**：~1200 行（单文件 `cJSON.c`）
    
- **适合场景**：掌握解析器设计，理解“零依赖”库的实现哲学
    

  

  

### **六、轻量级内存池：tcmalloc-minimal（C++，2000 行）**

#### **项目定位**：模仿 Google tcmalloc 的极简内存分配器

#### **核心学习点**：

- **分级管理**：小对象（<32KB）用 `Span` 链表，大对象直接分配
    
- **线程缓存**：`ThreadCache` 的无锁队列（`tls` 线程局部存储）
    
- **性能优化**：`CentralCache` 的批量回收（减少系统调用）
    
- **学习资源**：
    
    - GitHub 注释版：[venkman100/tcmalloc-minimal](https://github.com/venkman100/tcmalloc-minimal)（解析 `PageHeap` 的页管理）
        
    - 博客：[tcmalloc-minimal 源码解析：如何减少内存碎片](https://blog.csdn.net/qq_33334372/article/details/123456789)（对比 `malloc` 的性能）
        
- **代码量**：~2000 行（核心逻辑集中在 `tcmalloc.cc`）
    
- **适合场景**：理解内存分配器设计，解决 `malloc` 的性能瓶颈
    

  

  

### **七、极简 Web 服务器：webserver（C++，5000 行，Linux 课设级）**

#### **项目定位**：单线程/多线程版本的 HTTP 服务器，含完整注释

#### **核心学习点**：

- **Reactor 模式**：`EventLoop` 事件循环 + `Channel` 事件分发
    
- **HTTP 处理**：`HttpRequest` 的方法/路径解析（支持 GET/POST）
    
- **线程池**：`ThreadPool` 的任务队列（`std::queue` + 条件变量）
    
- **学习资源**：
    
    - GitHub 项目：[linyacool/WebServer](https://github.com/linyacool/WebServer)（含详细注释和部署教程）
        
    - B站视频：[手把手解析 WebServer 源码](https://www.bilibili.com/video/BV1qW411u7xZ)（调试 `HttpConn::process` 流程）
        
- **代码量**：~5000 行（分模块实现，适合逐步调试）
    
- **适合场景**：实战网络编程，对比 Muduo 的简化版实现
    

  

  

### **八、学习路径：从 1000 行到 1 万行（3 个月计划）**

|   |   |   |   |
|---|---|---|---|
|阶段|项目|目标|产出物|
|第 1 月|cJSON + http-parser|掌握解析器状态机，实现 JSON-over-HTTP|500 行的 HTTP+JSON 客户端|
|第 2 月|libco + tcmalloc-minimal|理解协程与内存分配，优化并发性能|1000 行的协程内存池 demo|
|第 3 月|linux-0.11 + webserver|内核启动 + 服务器开发，打通全链路|定制化的玩具级 Linux 发行版|

  

  

### **九、为什么选择这些项目？**

1. **轻量可控**：单个项目代码量 <1.5 万行，适合逐行精读（对比 Linux 5.x 的 2700 万行）。
    
2. **通用设计**：聚焦内存管理、协议解析、线程调度等底层能力，无行业知识依赖。
    
3. **实战闭环**：每个项目均可独立运行，支持调试（如用 GDB 跟踪 linux-0.11 的 `fork`）。
    
4. **资源密集**：均有中文注释、教程或视频，降低学习门槛（如《Linux 内核完全注释》配套模拟器）。
    

  

**推荐优先级**：从 `cJSON`（1200 行）和 `http-parser`（1200 行）入手，1 周内掌握解析器设计；再进阶 `libco`（5000 行），2 周理解协程调度；最后挑战 `linux-0.11`（1.5 万行），1 个月打通内核启动流程。每个项目搭配对应调试工具（如 GDB、Valgrind），确保代码逻辑可视化。