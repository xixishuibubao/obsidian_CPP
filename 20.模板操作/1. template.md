## 1. using和typedef

- C++11引入的using 可以使用using 代替typedef 。并且using 可以为尚未实例化完全的模板类型别名，
    

但是typedef只能为类型明确的别名。

- 模板定义必须在函数外。
    
- 成员类型和变量下划线后置是用户代码的典型做法，标准库则是以下划线开头。
    

  

```C++
template<typename T, typename U>
class MyClass {
public:
    T                     t_;
    U                     u_;
    typedef MyClass<T, U> Base_;      /* 这属于完全实例化 */
    typedef T             value_type; /* 这属于完全实例化 */
    typedef value_type*   p_value_type;
};

/* using可以不完全实例化，需要template*/
template<typename T>
using type1 = MyClass<T, char>;
/* typedef 只能完全实例化，不需要template*/
typedef MyClass<int, char> type2;
/* 完全实例化，不需要template*/
using MyType = MyClass<int, char>;
int main() {
    MyType         obj1;
    MyType::Base_  obj2;
    typeof(MyType) obj3; /* 这是一个gcc的拓展，并非C++标准特性 */
    decltype(obj3) obj4;
    return 0;
}
```

## 2. 偏特化，全特化

```C++
/* 模板参数在声明处只是占位符，模板类内部是什么，取决于你的class后面的特化/实例化参数 */
template<typename T,typename U>
class MyClass
{
using _MyType1 = T;
using _MyType2 = U;
};
/* 偏特化指特化部分模板参数，全特化，指明确所有模板参数，譬如int或者自定数据类型 */
/* 偏特化，T& T&& 同理 */
template<typename T>
class MyClass<T*,int>
{
using _MyType1 = T*;
using _MyType2 = int;
};

template<>
class MyClass<double,double>
{
using _MyType1 = double;
using _MyType2 = double;
};

/* 函数的特化同理,但是函数没有偏特化，需要靠重载实现类似偏特化特性*/
template<typename T,typename U>
T func(U);

template<typename T>
T func(std::string);

template<>
int func<int,int>(int);

func<int,double>(3.14); /* 调用通用模板 */
func<std::string>(std::string("test"));/* 调用重载模拟的偏特化 */
func<int,int>(1); /* 调用全特化 */
```

Decltype 类型推导编译时确定

## 3. 类与结构体

本质都是UDT（user_define_type）,所以是可以互相继承的，只是结构体默认是public，class默认是private

## 4. enable_shared_form_this<>

这是C++11引入的在 <memory>里的一个返回自身shared指针的基类。

## 5. 特殊的成员重载

仿函数：重载()操作符 auto operator()(形参列表){ }

  

/* 重载转换函数不需要额外声明返回值 */

重载转换函数：operator int(){return int(1);}

  

/* 这不会被识别为无参构造的调用，会优先识别为函数声明 */

无参构造：不可以在初始化的时候使用 MyClass obj();

## 6. 参数包

- C++11引入了可变参数模板，即可以有很多个模板参数的模板。
    

```c++
template <typename... Args>
class MyClass {
public:
    void func(Args... args) {
        (std::cout << ... << args);
    }
};
一定加上()，这种折叠表达式是C++17引入的
```