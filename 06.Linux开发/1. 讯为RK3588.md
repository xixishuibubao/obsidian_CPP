# 1. 驱动编译
## 1.1 要点与流程
- **编译模块的环境必须曾经编译过内核,内核必须是符合`C99`的`.c`文件**
### 1.1.1 最小内核文件`demo`
- ```c
  #include <linux/module.h>
  #include <linux/init.h>
  // 加载初始化函数必须是 int *()
  static int myinit(){ /*内核初始化函数，加载时自动触发，无需手动调用*/ 
	  printk("myinit\n"); // 不能用printf，要用printk，用法一样
	  return 0;
  }
// 卸载函数必须是 void *()
  static void myexit(){ /*内核退出函数，无需手动调用，卸载时自动触发*/
  }
  
  module_init(myinit);
  module_exit(myexit);
  MODULE_LICENSE("GPL"); //开源许可，必须
  /* 以下是非必须，会被保存到modinfo里
  MODULE_AUTHOR("gaochenxi");
  MODULE_VERSION("V1.0");
  */
  ```
  
### 1.1.2 `Makefile`模板
1. 
	```Makefile
		export ARCH=arm64 #设置架构
		export CROSS_COMPILE=/xxxxx/xxxx/aarch64-none-linux-gnu-   #设置编译器前缀
		#加了export 后面make的位置可以不用使用这两个变量，否则需要使用
		#make -C $(KDIR) M=$(PWD) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE)  modules
		
		KDIR=/xxxx/kernel #内核路径
		PWD?=$(shell pwd)
		  
		obj-m+=my.o #将内核模块的文件名保留，但文件类型变.o
		  
		all:
			make -C $(KDIR) M=$(PWD)   modules 
			# make xxxx modules 是编译内核的关键，其他的都是参数设置
			# -C 改变目录到KDIR(内核目录) M=实际要编译的模块文件在的目录
			
		clean:
			rm *.o *.mod *.mod.c *.order
	```

### 1.1.3 编译与部署

1. 回到模块所在路径执行`make -j`指令即可进行编译
2. 交叉编译完之后使用`scp`传输到开发板， 
   在开发板终端：`scp 远程侧用户名@ip:带绝对路径的文件名 本地保存目录`
3. 编译完成后的加载与卸载：
	- ```bash
		  sudo insmod  xxx.ko  #加载模块
		  lsmod                          #查看已加载的模块
		  sudo rmmod xxx.ko   #卸载已加载的模块
		  modinfo xxx.ko          #查看模块信息，作者 开源协议 版本 架构等
	  ```
### 1.1.4 `make menuconfig`
1. `make menuconfig`是一种通用的图形化配置方法，使用空格来切换选项状态。
	1. `[ ]`代表有两种模式,`[*] []`,选中和不选中，对应编译和不编译。
	2. `< >`代表有三种模式，`[M] [*] []`,对应将驱动编译为模块，编译进内核，和不编译。
	3. `( )`内部只可以填写十六进制或字符串。
2. 使用前要先设置架构`export ARCH=arm64`,`ARCH`代表架构，对应实际的来，`rk3588`是`arm64`的。
3. `make xxx_defconfig`根据`arch/xxx/configs`中的`kconfig`文件生成`.config`文件，`xxx`代表架构。

### 1.1.5 `Kconfig`语法
- ```bash
  	   config helloworld
        bool "helloworld support"
        default y
        help
            my helloworld
  ```
1. 上面是增加一个自定的`helloworld`驱动编译进内核的操作，除了在`helloworld`文件夹下创建这样的`Kconfig`文件，还要创建对应的`Makefile`如下
```Makefile
	obj-$(CONFIG_helloworld) += helloworld.o
	# CONFIG_helloworld正是由Kconfig生成的一个变量，其名字和你前面写的Kconfig文件有关。
```
然后退回到上一级目录,这里我们假设它是一个`drivers/char/`类型的驱动，所以要修改`/char`目录下的`Kconfig`文件，`source "drivers/char/helloworld/Kconfig"`，`source`以文件内容直接引入(类似`#include`)
