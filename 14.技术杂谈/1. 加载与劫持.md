# 1. 手动加载动态库
## 1.1 `demo`
### 1.1.1 调用方
```C++
	#include <dlfcn.h>
	void myfunc() {
		void* handle = dlopen("./libmylib.so",RTLD_NOW | RTLD_LOCAL);
		if(!handle) {
			cout << dlerror();
			return;
			}
		dlclose(handle);
		unlink("./libmylib.so") 
	}
```
1. `void* handle = dlopen(libname，flags)`,加载动态库，返回句柄。
	1. 库名不识别`~/`,但识别相对路径`./`，且为完整库名，不可省略前面的`lib`。
	2. `flags`常用组合：
		1. `RTLD_NOW | RTLD_LOCAL`,立刻加载，只加载库本身符号表，库不可访问原程序内容。
		2. `RTLD_NOW | RTLD_GLOBAL`,立即加载，且共享主程序符号表，库可访问其变量和方法。
		3. **库要访问原程序内容，需要编译的时候添加`-rdynamic`,共享符号表不然库识别不到。**
2. `dlerror()`,会显示库加载失败的原因，返回值为字符串。
	1. `dlerror()`调用后会清除上一次的`errorcode`。
3. `dlclose(handle)`,从程序中卸载库，关闭句柄。
4. `unlink(libname)`,对于一次性库，用完后使用`unlink`删除，其作用等价于`rm libname`。
### 1.1.2 so库
```c++
	/* .so加载时自动执行（constructor属性，无需主程序调用）*/
	__attribute__((constructor)) 
	void init_collect() { }
	/* .so卸载时自动执行（constructor属性，无需主程序调用）*/
	__attribute__((destructor)) 
	void cleanup() { }
```
- 如果原程序需要加载并调用库的函数，要将其使用`extern "C" { }`包裹，避免编译后函数名被`c++`规则混淆，无法正确识别到并加载。

# 2. 劫持动态库
- 劫持要求ABI一致，推荐使用`extern "C" { }`保证注入和劫持函数的ABI一致性。
## 2.1 环境变量劫持
### 2.1.1 `LD_PRELOAD`预加载劫持
- `LD_PRELOAD=liba.so:libb.so ./myexe`,多个库名之间用`:`间隔开。
- 优先级从左到右依次减小，同名库多次劫持以最先加载的为准。
### 2.1.2 `LD_LIBRARY_PATH`,劫持库目录
- `LD_LIBRARY_PATH=/mylib:PATH`，原理和`LD_PRELOAD`相同，先加载的优先级更高。