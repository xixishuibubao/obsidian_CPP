## 1.动态库和静态库
### 1.1 命名格式

- unix: 
	- `静态.a`
	- `动态.so[.主版本号.次版本号.发布版本号]`

- win: 
	- `静态 .lib`
	- `动态.dll`

### 1.2静态库
#### 1.2.1 生成静态库
- `ar [选项] [归档文件名] [文件列表]`
- `ar crsv 库名.a 所有依赖的.o`
	`[选项]`的常用参数:
	
	- `c` 创建
	- `r` 添加或替换依赖的`.o`
	- `s` 生成索引
	- `v `显示版本号
	- `x `提取库中的`.o`

#### 1.2.2 查看静态库

- `ar t [归档文件名]`, `t` 代表查看库内容列表
- 要让静态库可以被调用，要将`.a`移动到`/usr/lib`中,`mv 库.a /usr/lib`

### 1.3 动态库
#### 1.3.1 生成动态库

- 生成动态库的方式是使用`gcc -shared`
- 依赖的`.o`生成的时候要加上 `-fpic`选项,
   `-fpic`是为了使库中的函数和变量内存地址动态处理，不绑定固定物理位置
- 流程如下：
	1. `gcc -c text.c -fpic`
	2. `gcc -shared 所有依赖.o -o libalgs.so[.v.v.v]`

- 想让动态库可以被调用，要将`.so`移动到`/usr/lib`中,`mv 库.so /usr/lib`

#### 1.3.2更新依赖的库版本

- 动态调整库版本流程：
	1. 首先可执行文件编译时链接到不含版本号的`.so`,`gcc -o main.c -l test`
	2. 创建一个指向通用版本的链接符号，当动态库更新时，我们只需要更新这个软链接。
		- `ln -s [目标] [链接符号]`,`soft`软链接`h`硬链接
		- `ln -s libtest.so.0.0.2 libtest.so`
	3. `gcc main.c -l test -o main`,(不要包含`.a`或`.so`)

#### 1.3.3 符号可见性

- 控制动态库的符号外部可见性，首先要在对应的函数实现的`.c .cpp`中函数声明处使用。
	1. `__attribute__((visibility("default")))`, 这意味着其外部可见性是默认的(可见的)。
	2. `__attribute__((visibility("hidden")))`, 修饰，这意味着其外部可见性是隐藏的。
	3. `__attribute__((aligned(n)))` n字节对齐

- 在链接的时候要使用
	1. `gcc -shared -fvisibility=hidden -o mylib.so mysource.cpp` ,除了显式设置为可见的部分 其他的都是不可见的。
	2. `gcc -shared -fvisibility=default -o mylib.so mysource.cpp` 除了显式设置为不可见的函数和变量 ，其他都是可见的。
	3. 使用`-fvisibility=default`和`gcc -shared mysource.o -o mylib.so` 等价。