# 1.  开发环境
## 1.1 go下载安装
1. `go`本身是自带全平台的编译工具链的，工具链在[go官网](https://golang.google.cn/ "golang官网")下载。
2. 安装完`go`需要将`bin`路径添加到环境变量`PATH`中。
## 1.2 编译运行
### 1.2.1 常用命令
1. `go build  -o main file.go`,编译并保存文件输出为`main`
2. `go run file.go`,编译并运行，不保存编译结果。

# 2. 基本格式
## 2.1 最小demo
```go
	package main /* 定义包名，可执行程序必须为main，且包名也是其他go文件导入该模块时的名字*/
	import "fmt" /* 导入模块“fmt”*/
	
	func main() {
		fmt.Println("hello world");
	}
```

## 2.2 `import`
### 2.2.1 基础导入
```go
	// go注释和C++一样，两种都支持
	/* go注释和C++一样，两种都支持 */
	
	/* 方法1：单个导入*/
	import "fmt"
	import "myimport"
	
	/* 方法2：统一导入*/
	import(
		"fmt"
		"myimport"
	)
	
	/* 同一个包多次导入会报错，无法编译通过。*/
	
```
### 2.2.2 别名/匿名导入
```go
	import(
		myfmt "fmt"	/* 导入后可以用别名访问,同时原包名就不可用了  */
		_ "GCX" /* 匿名导入后未使用的模块不会报错，但其对应的init还会运行  */
	)
	
	myfmt.Println("hello world") 
	
```
## 2.3 变量
### 2.3.1 基本类型
1. 基本数据类型：
	1. `uint uint8 uint16 uint32 int int8 int16 int32 `
	2. `float32 float64`,`go`没有`double`,但有`float64`。
	3. `string`原生字符类型。
	4. `bool`,布尔类型`true false`。
	5. `byte`原生单字节。
	6. `complex complex64 complex128`,原生复数。
	7. `chan <-chan chan<-`,通道、只读通道、只写通道，通道可以被隐式转化为单向通道。

### 2.3.2 命名规则
1. 变量命名规则和`C++`一样，不可以**数字开头**，必须以**下划线和字母**开始。
2. **不使用的局部变量会报错。**
3. **首字母大写代表外部导入后可见，首字母小写代表仅在本模块可见。**
4. **`go`的类型是后置的。**


### 2.3.3 变量声明
1. 声明变量的几种方法：
	1. `var name int`,常用于不需要初始化的全局变量。
	2. `var name [int] = 1`,给定初值的时候会自动推导类型，可以缺省类型`int`。
	3. `var := 1`,只可以在函数内使用，是前一种方式的简化。
	4. `var a,b,c = 1,2,3`,可以统一定义初始化。

2. 数据类型转换,`var a= float32(15.5)`,函数调用式的。
3. `go`也有`const`，`const a = 15`,定义常量。

### 2.3.4 操作符
1. 指针：
	1. `var a *int = &b`,指针标识也是后置的。
	2. `*a = 1`,访问指针的方式和`C++`一样。
2. 成员访问：
	1. 不论`a`是自定类型的**对象还是指针**，**成员都用`.`访问。**
3. `&& || ! ++ -- + - * / << >> &`等基础操作符以及其衍生符号`+= `之类的和`C++`用法一样。
4.  `go`只有`i++`没有`++i`。
### 2.3.5 枚举
- `go`没有枚举，但是可以用`const`来处理。

1. 
   ```go
	const (  
	    A1, AA, BA = iota, 2 * iota, 1 << iota // 0, 0, 1 << 0  
	    A2, AB, BB                             // 1, 2, 1 << 1  
	)
	   /* 
		   1. iota是一个从0开始的自增标识，每次换行会自增,只有换行才自增。
		   2. 使用iota后，每行都遵循上一行的格式
	   */
   ```

2. `const`在`go`仅能修饰变量，不能修饰函数的形参和返回值。


## 2.4 函数
### 2.4.1 基本格式
1. ```go
	   func myfunc(value int) int{ 
		   return 1
	   }
   ```
2. 用`func`在头部声明，类型和返回值都后置，且`{`必须和函数名在同一行。
### 2.4.2 多返回值

## 2.5 条件语句
### 2.5.1 `if`语句
1. `if`用法和`C++`完全一样，但是不需要`()`包围判断条件
### 2.5.2 `switch`语句
- `switch`和`C++`有很大不同。
- ```go
	  switch myvar{ /* switch不需要 break */
		  case 1,2,3:
		  case 4,5:
		  default:
	  }
	  
	  /*格式2 无参数形式 */
	  	  switch {
		  case true: /*  为true则执行，且只执行第一个*/
		   case true: /*  不执行第二个true*/
		  case false:
		  case 1==1 : /* case的匹配也可以是bool表达式 */
		  default:
	  }
  ```
- `fallthrough` 会强制执行下一个分支不会判断其是否匹配值。
  ```go
	    switch {
	    case true:
	            fmt.Println("1、case 条件语句为 false")
	            fallthrough
	    case false:
	            fmt.Println("2、case 条件语句为 true")
	            fallthrough
	    default:
	            fmt.Println("6、默认 case")
	    }
	    /* 结果是全部输出 */
  ```

### 2.5.3 `select`
- `select`只能用于通道操作，每次select会随机选择一个就绪通道运行，若都没有则运行`default`.
- ```go
	  for {  /*   这里没有结束条件所以是无限循环    */
	    select {  
	    case msg1 := <-ch1:  
	       fmt.Println(msg1)  
	    case msg2 := <-ch2:  
	       fmt.Println(msg2)  
	    default:  
	       // 如果两个通道都没有可用的数据，则执行这里的语句  
	       fmt.Println("no message received")  
	    }  
	}
  ```
## 2.6 循环语句
### 2.6.1 `for`循环
1. **`for`循环和`C++`除了没括号完全一致，同时`go`没有`while`,可以用`for{ }`来实现`while(true)`**
2. 相关的流程控制关键字，`break continue goto`用法和`C++`也一致。

## 2.7 函数
### 2.7.1 基本格式
- `func关键字 函数名 (形参列表[类型后置]) 返回值类型[多个返回值用,隔开且要用()包围，单个不需要()] { [左括号和函数名行对齐]`
- 形参和返回值不可以用`const`修饰
- 接收的时候多返回值接收变量不需要`()`包围
```go
func funcname(valuename type) (returntype1，returntype2){ 
}
a,b :=funcname(c)
```

### 2.7.2 `init`函数
- **每个`package`都可以写一个`init`函数在别人导入他的时候会自动运行**
- ```go
	  func init(){ /* 必须无返回值，无形参*/
	  }
  ```
- `go`模块加载机制：
	- 先初始化所有依赖包，再初始化主包（`main`）
	- 每个包内的初始化顺序：先初始化常量 → 变量 → `init()` 函数
	- 同一个包的多个 `init()` 函数会按文件名称序执行，但整体只执行一轮

### 2.7.3 接收者方法
- 接收者方法可以实现自动绑定，呈现出类似`C++`成员方法的调用形式。
- `func (接收者变量 接收者类型) 方法名(参数列表) (返回值列表) {`
- ```go
		func (my *mytype) myfunc1() {
		}
		func (my mytype) myfunc2() {
		}
		mytype s
		s2 := &s
		
		s.myfunc1() /* s会自动转为为指针调用 */
		s2.myfunc1()
		
		s.myfunc2()
		s2.myfunc2() /* s2会自动转为为副本调用 */
		
  ```
- 调用的时候，直接对象/指针 然后`.`访问。访问的时候会自动识别接收者类型并转化为相应函数的接收者指针或副本。

### 2.7.4 闭包
- 闭包可以直接使用函数内的变量而不必申明
- ```go
	package main
	import "fmt"
	// 每次的返回函数都是独立计数
	func getSequence() func() int {
	   i:=0
	   return func() int {
	      i+=1
	     return i  
	   }
	}
	
	func main(){
	   /* nextNumber 为一个函数，函数 i 为 0 */
	   nextNumber := getSequence()  
	
	   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
	   fmt.Println(nextNumber()) // 1
	   fmt.Println(nextNumber()) //2
	   
	   /* 创建新的函数 nextNumber1，并查看结果 */
	   nextNumber1 := getSequence()  
	   fmt.Println(nextNumber1()) // 1
	   fmt.Println(nextNumber1()) // 2
	}
  ```

## 2.8 数组
### 2.8.1 一维数组
- `[]前置`,`var myarr [10]int`,声明一个名为`myarr`的`10`个元素数组
- `numbers := [5]int{1, 2, 3, 4, 5}`,使用`{}`初始化
- 如果数组长度不确定，可用`...`代替长度，编译器会根据元素个数自行推断数组的长度
	- `var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`，格式1
	- `var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}`，格式2
	- 以上两行`balance`不是同一个类型,若函数形参使用数组需要精确匹配
	- 在`go`,数组名`!=`指针，不能使用`C++`那种方法来以指针形式接收数组形参，但是可以用`[]`或`*[]`，`[]`或`*[]`做形参可以接收任意长度数组,但对应的数组定义时也必须是无长度形式(格式2)
	- ```go
func myfunc( my []int) { 
	  ```
### 2.8.2 多维数组
- `var myarr [x][y][z]int`,和`C++`类似，分别对应行列高。
- ```go
   // 创建一个3x3的矩阵  
	matrix := [3][3]int{  
		{1, 2, 3},  
		{4, 5, 6},  
		{7, 8, 9},  
	}
  ```

### 2.8.3 `range`
- `range`会返回`k,v`键值对，常用于遍历,`_`代表丢弃某个返回值。
- ```go
		  // 创建一个二维数组  
		scores := [3][4]int{  
			{85, 90, 78, 92},  
			{88, 76, 95, 89},  
			{92, 85, 88, 90},  
		}  
		 
		fmt.Println("学生成绩表:")  
		 
		// 使用 range 遍历二维数组  
		for i, row := range scores {  
			fmt.Printf("学生 %d 的成绩: ", i+1)  
			for _, score := range row {  
				fmt.Printf("%d ", score)  
	
			}  
			fmt.Println()  
		}
  ```


## 2.9 指针
### 2.9.1 空指针
- `go`的空指针为`nil`，但`nil`不仅仅是空指针，还是空切片等各种空。

### 2.9.2 常规用法
- 和`C++`一致

## 2.10 结构体`struct`
### 2.10.1 基本格式
- `type mystruct struct{ }`
- **私有成员首字母小写，公有成员首字母大写**
- ```go
  	type mystruct struct{
		 var1 int
		 var2 string
		 Var3 int
		 Var4 string
	}
  ```
### 2.10.2 成员访问
- **无论是指针还是对象，都用`.`访问成员**
- 其他用法和`C++`相同

## 2.11 切片
### 2.11.1 基本用法
- `varname []type`,这种类似数组但不带长度的动态数组结构就叫切片。

1. 使用`make`创建，`myvar := make([]T, length, capacity)`。
2. `myvar = append(myvar，var_)`,在切片后追加元素`var_`。
	- 返回值是追加的关键，不使用用原切片接收返回值则原切片不会改变。
	- 若使用一个新的切片接收返回值，则新切片是追加后的，原切片不变。
	- `append`的第一个形参是值传递，不是指针。
3. `cap(myvar)`,获取切片的容量`capacity`。
4. `len(myvar)`,获取切片元素个数`length`。
5. 空切片为`nil`。
	- ```go
		var numbers []int
		if numbers == nil //结果为true
	  ```

### 2.11.2 切片结构
```go
	struct Slice
	{   
	    byte*    array;       // actual data
	    uintgo    len;        // number of elements
	    uintgo    cap;        // allocated number of elements
	
	}
```

### 2.11.3 切片截取
- **切片截取是左闭右开`[x,y)`,`x y`均可缺省，缺省的部分会被表示为边界，该边界包含头尾元素**
- 切片截取是浅拷贝，因此共享数据，一处修改全部修改。


## 2.12 `map`
### 2.12.1 基本用法
- `go`的`map`底层数据结构是`hash表`和`hash桶`,因此是无序的。
- 创建使用`mymap := make( map[ktype]vtype, [capacity] )`,`capacity`可缺省。
- `delete（map,k）`可以删除`map`中的元素。
- `v,flag := mymap[key]`,返回值依次为`k对应的值`和`成功标志`。

## 2.13 `range`
### 2.13.1 基本用法
1. `range`用于获取容器的范围内容，常用于遍历。
2. ```go
	   nums := {0,1,2}
	   ch = make(chan int)
	   ch <- 1
	   ch <- 2
	   close(ch)
	   
	   for num := range nums{ /*  前面的num不用可以缺省，其他容器比如map同理 */
	   }
	   for k,_ := range maps{  // 使用_来忽略某个提取值
	   }
	   
	   for c := range ch{ /* 直到chan通道关闭，不关闭则一直循环  */
	   }
   ```

## 2.14 接口`interface`
### 2.14.1 用法
- `interface`类似`C++`的**虚基类**,可以承接任意实现了该接口所有方法的对象。
- 格式 `type classname interface{ 一系列方法声明}`
- ```go
	type myinterface interface {  
	    MyPrintln(int) (int, int)  
	}  
	type mystruct struct {  
	    c int  
	}  
	  
	func (_ *mystruct) MyPrintln(a int) (int, int) {  
	    fmt.Println("MyPrintln1")  
	    return a, 0  
	}  
	
	type mystruct2 struct {  
	    c int  
	}  
	  
	func (_ *mystruct2) MyPrintln(a int) (int, int) {  
	    fmt.Println("MyPrintln2")  
	    return a, 0  
	}  
	func main() {  
	    a  := mystruct{1}  
	    b := mystruct2{2}  
	    a.MyPrintln(3)  
	    b.MyPrintln(4)
	}
  ```
### 2.14.2 通用接口
- `interface {}`，空接口是通用接口
- `interface {} == nil`，的结果是`true`
- 任何类型都实现了空接口
```go
package main  
  
import "fmt"  
  
func printValue(val interface{}) {  
        fmt.Printf("Value: %v, Type: %T\n", val, val)  
}  
  
func main() {  
        printValue(42)         // int  
        printValue("hello")    // string  
}
```

## 2.15 断言
### 2.15.1 类型断言
- `value := iface.(Type)`,必须要加`()`
	- `iface` 是接口变量
	- `Type` 是要断言的具体类型
	- 如果类型不匹配，会触发 `panic`
	- 如果类型匹配，则返回值value会自动推导为`Type`类型
- ```go
	package main  
	import "fmt"  
	  
	func main() {  
	        var i interface{} = "hello"  
	        str := i.(string) // 类型断言  
	}
  ```
### 2.15.2 带检测的类型断言
- `value, ok := iface.(Type)`
	- `ok` 是一个布尔值，表示断言是否成功
	- 如果断言失败，`value` 为零值，`ok` 为 `false`
- ```go
        var i interface{} = 42
        if str, ok := i.(string); ok {  //断言失败，但是不会报错，会进入if的false分支
                fmt.Println("String:", str)
        } else {
                fmt.Println("Not a string")
        }
}
  ```
### 2.15.3 断言与类型处理
- 可以使用`if`或者`switch`处理类型与断言
- ```go
	  switch t := i.(type){
	  case int :
	  case string:
	  default:
	  }
	  
	  if str,ok := i.(string);ok{
	  }else{
	  }
  ```

## 2.16 继承
- `go`没有类似`C++`的继承体系，通过包含匿名的`interface`或`struct`来模拟继承
- `struct`方式
	- ```go
		package main  
		import "fmt"  
		  
		type Vehicle struct {  
		       Brand string  
		}  
		
		func (v *Vehicle) Start() {  
		    fmt.Println(v.Brand, "started")  
		}  
		  
		type Car struct {  
		    Vehicle  //默认名字和类型相同，外部访问会穿透到内部接口，如果用自定名就不可以穿透
		    Model string  
		}  
		  
		func (c *Car) Start() {  
		    fmt.Println(c.Brand, c.Model, "car started")  
		}  
		  
		func main() {  
		    v := Vehicle{Brand: "Toyota"}  
		    c := Car{  Vehicle{Brand: "Honda"},   "Civic"}  
		  
		    v.Start()           
		    c.Start()           
		    c.Vehicle.Start()   
		}
	  ```
- `interface`方式
	- ```go
		package main
		import "fmt"
		
		type Speaker interface {
		    Speak()
		}
		
		type Animal struct {
		    Name string
		}
		
		func (a *Animal) Speak() {
		    fmt.Println(a.Name, "says hello!")
		}
		
		type Dog struct {
		    Animal
		    Breed string
		}
		
		func main() {
		    var speaker Speaker
		    dog := Dog{Animal{Name: "Buddy"},  "Golden Retriever"}
		
		    speaker = &dog
		    speaker.Speak() 
		}
		  ```

## 2.17 泛型
- `go`的泛型原生就带约束。
- 格式为`[T any], [T ...any],[T any,P any]`，其中`T`是泛型名，`any`是一种`go`自带约束类型。
	- `any`任意类型
	- `comparable`可比较类型
	- `...`不定参数包，可接收任意数量的参数，但约束相同，常用于`func`
	- `int`等基础类型也可做为约束条件
	- 自定的`intface`也可以作为约束
	- **结构体、`func`、`map`都支持泛型**
- 泛型函数的格式
	- `func （接收者）funcname[约束]（形参）（返回值列表）{}`
- 自定义约束泛型函数
	- ```go
		type Stringer interface {
		    String() string
		}
		
		func PrintString[T Stringer](value T) {
		    fmt.Println(value.String())
		}

		type Person struct {
		    Name string
		    Age  int
		}
		
		func (p Person) String() string {
		    return fmt.Sprintf("%s (%d years old)", p.Name, p.Age)
		}

		person := Person{Name: "Alice", Age: 25}
		PrintString(person)  // 输出: Alice (25 years old)
		PrintString(1) //不满足约束会报错
	  ```
- 泛型结构体
	- ```go
		  type Stack[T any] struct {  
		    elements []T  
		}  
		  
		func (s *Stack[T]) Push(value T) {  
		    s.elements = append(s.elements, value)  
		}
	  ```
- 泛型`map`
	- ```go
		type SafeMap[K comparable, V any] struct {  
		    data map[K]V  
		    mutex sync.RWMutex  
		}  
		  
		
		func NewSafeMap[K comparable, V any]() *SafeMap[K, V] {  
		    return &SafeMap[K, V]{  
		        data: make(map[K]V),  
		    }  
		}
		tmp := NewSafeMap[int,string]()
	  ```

## 2.18 错误`error`
- 原生`error`需要导入相关包
	- `import "errors"`
	- `errors.New("my error")`,创建一个错误
- `error`本身是一个接口，任何实现了`Error() string`方法的结构体都可以作为`error`
- 返回值如果包括`error`类型，要显式的处理，或用`_`承接来忽略
- ```go
		package main
		import "fmt"
		
		type DivideError struct {
		        Dividend int
		        Divisor  int
		}
		
		func (e *DivideError) Error() string {
		        return fmt.Sprintf("cannot divide %d by %d", e.Dividend, e.Divisor)
		}
		
		func divide(a, b int) (int, error) {
		        if b == 0 {
		                return 0, &DivideError{Dividend: a, Divisor: b}
		        }
		        return a / b, nil
		}
		
		func main() {
		        _, err := divide(10, 0)
		        if err != nil {
		                fmt.Println(err) // 输出：cannot divide 10 by 0
		        }
		}
	  ```
## 2.19 并发
### 2.19.1 协程
- 开启协程：
	- `go myfunc(vale)`,开启一个协程调用`myfunc`
	- 也可以是匿名函数，`go func(){}()`
### 2.19.2 通道`chan`
- 通道有两种，带缓冲和不带缓冲区的。
	- 不带缓冲，收发都会阻塞。`ch := make(chan int)`
	- 带缓冲，收发是异步的，缓冲满之前不会阻塞。`ch := make(chan int,缓冲区大小)`
### 2.19.3 `WaitGroup`
- `WaitGroup`需要`import "sync"`,`WaitGroup`可以等待多个协程完毕。
- `sync.WaitGroup`

## 2.20 文件操作
- `os io bufio`几个模块提供了文件操作的基本方法。
	1. **`os` 是核心库**：提供底层文件操作（创建、读写、删除等），大多数场景优先使用。
	2. **`io` 提供通用接口**：如 `Reader`/`Writer`，可与文件、网络等数据源交互。
	3. **`bufio` 优化性能**：通过缓冲减少 I/O 操作次数，适合频繁读写
- ```go
  import(
	  "os"
	  "io"
	  "bufio"
  )
  ```