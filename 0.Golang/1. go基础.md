# 1.  开发环境
## 1.1 go下载安装
1. `go`本身是自带全平台的编译工具链的，工具链在[go官网](https://golang.google.cn/ "golang官网")下载。
2. 安装完`go`需要将`bin`路径添加到环境变量`PATH`中。
## 1.2 编译运行
### 1.2.1 常用命令
1. `go build  -o main file.go`,编译并保存文件输出为`main`
2. `go run file.go`,编译并运行，不保存编译结果。

# 2. 基本格式
## 2.1 最小demo
```go
	package main /* 定义包名，可执行程序必须为main，且包名也是其他go文件导入该模块时的名字*/
	import "fmt" /* 导入模块“fmt”*/
	
	func main() {
		fmt.Println("hello world");
	}
```

## 2.2 `import`
### 2.2.1 基础导入
```go
	// go注释和C++一样，两种都支持
	/* go注释和C++一样，两种都支持 */
	
	/* 方法1：单个导入*/
	import "fmt"
	import "myimport"
	
	/* 方法2：统一导入*/
	import(
		"fmt"
		"myimport"
	)
	
	/* 同一个包多次导入会报错，无法编译通过。*/
	
```
### 2.2.2 别名/匿名导入
```go
	import(
		myfmt "fmt"	/* 导入后可以用别名访问,同时原包名就不可用了  */
		_ "GCX" /* 匿名导入后未使用的模块不会报错，但其对应的init还会运行  */
	)
	
	myfmt.Println("hello world") 
	
```
## 2.3 变量
### 2.3.1 基本类型
1. 基本数据类型：
	1. `uint uint8 uint16 uint32 int int8 int16 int32 `
	2. `float32 float64`,`go`没有`double`,但有`float64`。
	3. `string`原生字符类型。
	4. `bool`,布尔类型`true false`。
	5. `byte`原生单字节。
	6. `complex complex64 complex128`,原生复数。
	7. `chan <-chan chan<-`,通道、只读通道、只写通道，通道可以被隐式转化为单向通道。

### 2.3.2 命名规则
1. 变量命名规则和`C++`一样，不可以**数字开头**，必须以**下划线和字母**开始。
2. **不使用的局部变量会报错。**
3. **首字母大写代表外部导入后可见，首字母小写代表仅在本模块可见。**
4. **`go`的类型是后置的。**


### 2.3.3 变量声明
1. 声明变量的几种方法：
	1. `var name int`,常用于不需要初始化的全局变量。
	2. `var name [int] = 1`,给定初值的时候会自动推导类型，可以缺省类型`int`。
	3. `var := 1`,只可以在函数内使用，是前一种方式的简化。
	4. `var a,b,c = 1,2,3`,可以统一定义初始化。

2. 数据类型转换,`var a= float32(15.5)`,函数调用式的。
3. `go`也有`const`，`const a = 15`,定义常量。

### 2.3.4 操作符
1. 指针：
	1. `var a *int = &b`,指针标识也是后置的。
	2. `*a = 1`,访问指针的方式和`C++`一样。
2. 成员访问：
	1. 不论`a`是自定类型的**对象还是指针**，**成员都用`.`访问。**
3. `&& || ! ++ -- + - * / << >> &`等基础操作符以及其衍生符号`+= `之类的和`C++`用法一样。
4.  `go`只有`i++`没有`++i`。
### 2.3.5 枚举
- `go`没有枚举，但是可以用`const`来处理。

1. 
   ```go
	const (  
	    A1, AA, BA = iota, 2 * iota, 1 << iota // 0, 0, 1 << 0  
	    A2, AB, BB                             // 1, 2, 1 << 1  
	)
	   /* 
		   1. iota是一个从0开始的自增标识，每次换行会自增,只有换行才自增。
		   2. 使用iota后，每行都遵循上一行的格式
	   */
   ```

2. `const`在`go`仅能修饰变量，不能修饰函数的形参和返回值。


## 2.4 函数
### 2.4.1 基本格式
1. ```go
	   func myfunc(value int) int{ 
		   return 1
	   }
   ```
2. 用`func`在头部声明，类型和返回值都后置，且`{`必须和函数名在同一行。
### 2.4.2 多返回值

## 2.5 条件语句
### 2.5.1 `if`语句
1. `if`用法和`C++`完全一样，但是不需要`()`包围判断条件
### 2.5.2 `switch`语句
- `switch`和`C++`有很大不同。
- ```go
	  switch myvar{ /* switch不需要 break */
		  case 1,2,3:
		  case 4,5:
		  default:
	  }
	  
	  /*格式2 无参数形式 */
	  	  switch {
		  case true: /*  为true则执行，且只执行第一个*/
		   case true: /*  不执行第二个true*/
		  case false:
		  case 1==1 : /* case的匹配也可以是bool表达式 */
		  default:
	  }
  ```
- `fallthrough` 会强制执行下一个分支不会判断其是否匹配值。
  ```go
	    switch {
	    case true:
	            fmt.Println("1、case 条件语句为 false")
	            fallthrough
	    case false:
	            fmt.Println("2、case 条件语句为 true")
	            fallthrough
	    default:
	            fmt.Println("6、默认 case")
	    }
	    /* 结果是全部输出 */
  ```

### 2.5.3 `select`
- `select`只能用于通道操作，每次select会随机选择一个就绪通道运行，若都没有则运行`default`.
- ```go
	  for {  /*   这里没有结束条件所以是无限循环    */
	    select {  
	    case msg1 := <-ch1:  
	       fmt.Println(msg1)  
	    case msg2 := <-ch2:  
	       fmt.Println(msg2)  
	    default:  
	       // 如果两个通道都没有可用的数据，则执行这里的语句  
	       fmt.Println("no message received")  
	    }  
	}
  ```
## 2.6 循环语句
### 2.6.1 `for`循环
1. **`for`循环和`C++`除了没括号完全一致，同时`go`没有`while`,可以用`for{ }`来实现`while(true)`**
2. 相关的流程控制关键字，`break continue goto`用法和`C++`也一致。

## 2.7 函数
### 2.7.1 基本格式
- `func关键字 函数名 (形参列表[类型后置]) 返回值类型[多个返回值用,隔开且要用()包围，单个不需要()] { [左括号和函数名行对齐]`
- 形参和返回值不可以用`const`修饰
- 接收的时候多返回值接收变量不需要`()`包围
```go
func funcname(valuename type) (returntype1，returntype2){ 
}
a,b :=funcname(c)
```

### 2.7.2 `init`函数
- **每个`package`都可以写一个`init`函数在别人导入他的时候会自动运行**
- ```go
	  func init(){ /* 必须无返回值，无形参*/
	  }
  ```
- `go`模块加载机制：
	- 先初始化所有依赖包，再初始化主包（`main`）
	- 每个包内的初始化顺序：先初始化常量 → 变量 → `init()` 函数
	- 同一个包的多个 `init()` 函数会按文件名称序执行，但整体只执行一轮

### 2.7.3 接收者方法
- 接收者方法可以实现自动绑定，呈现出类似`C++`成员方法的调用形式。
- `func (接收者变量 接收者类型) 方法名(参数列表) (返回值列表) {`
- ```go
		func (my *mytype) myfunc1() {
		}
		func (my mytype) myfunc2() {
		}
		mytype s
		s2 := &s
		
		s.myfunc1() /* s会自动转为为指针调用 */
		s2.myfunc1()
		
		s.myfunc2()
		s2.myfunc2() /* s2会自动转为为副本调用 */
		
  ```
- 调用的时候，直接对象/指针 然后`.`访问。访问的时候会自动识别接收者类型并转化为相应函数的接收者指针或副本。

### 2.7.4 闭包
- 闭包可以直接使用函数内的变量而不必申明
- ```go
	package main
	import "fmt"
	// 每次的返回函数都是独立计数
	func getSequence() func() int {
	   i:=0
	   return func() int {
	      i+=1
	     return i  
	   }
	}
	
	func main(){
	   /* nextNumber 为一个函数，函数 i 为 0 */
	   nextNumber := getSequence()  
	
	   /* 调用 nextNumber 函数，i 变量自增 1 并返回 */
	   fmt.Println(nextNumber()) // 1
	   fmt.Println(nextNumber()) //2
	   
	   /* 创建新的函数 nextNumber1，并查看结果 */
	   nextNumber1 := getSequence()  
	   fmt.Println(nextNumber1()) // 1
	   fmt.Println(nextNumber1()) // 2
	}
  ```

## 2.8 数组
### 2.8.1 一维数组
- `[]前置`,`var myarr [10]int`,声明一个名为`myarr`的`10`个元素数组
- `numbers := [5]int{1, 2, 3, 4, 5}`,使用`{}`初始化
- 如果数组长度不确定，可用`...`代替长度，编译器会根据元素个数自行推断数组的长度
	- `var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}`，格式1
	- `var balance = []float32{1000.0, 2.0, 3.4, 7.0, 50.0}`，格式2
	- 以上两行`balance`不是同一个类型,若函数形参使用数组需要精确匹配
	- 在`go`,数组名`!=`指针，不能使用`C++`那种方法来以指针形式接收数组形参，但是可以用`[]`或`*[]`，`[]`或`*[]`做形参可以接收任意长度数组,但对应的数组定义时也必须是无长度形式(格式2)
	- ```go
func myfunc( my []int) { 
	  ```
### 2.8.2 多维数组
- `var myarr [x][y][z]int`,和`C++`类似，分别对应行列高。
- ```go
   // 创建一个3x3的矩阵  
	matrix := [3][3]int{  
		{1, 2, 3},  
		{4, 5, 6},  
		{7, 8, 9},  
	}
  ```

### 2.8.3 `range`
- `range`会返回`k,v`键值对，常用于遍历,`_`代表丢弃某个返回值。
- ```go
		  // 创建一个二维数组  
		scores := [3][4]int{  
			{85, 90, 78, 92},  
			{88, 76, 95, 89},  
			{92, 85, 88, 90},  
		}  
		 
		fmt.Println("学生成绩表:")  
		 
		// 使用 range 遍历二维数组  
		for i, row := range scores {  
			fmt.Printf("学生 %d 的成绩: ", i+1)  
			for _, score := range row {  
				fmt.Printf("%d ", score)  
	
			}  
			fmt.Println()  
		}
  ```


## 2.9 指针
### 2.9.1 空指针`nil`
- `go`的空指针为`nil`

### 2.9.2 常规用法
- 和`C++`一致

## 2.10 结构体`struct`
### 2.10.1 基本格式
- `type mystruct struct{ }`
- **私有成员首字母小写，公有成员首字母大写**
- ```go
  	type mystruct struct{
		 var1 int
		 var2 string
		 Var3 int
		 Var4 string
	}
  ```
### 2.10.2 成员访问
- **无论是指针还是对象，都用`.`访问成员**
- 其他用法和`C++`相同

## 2.11 切片
### 2.11.1 基本用法
- 