以下是 **通用、规范且适配绝大多数 C++ 开源项目** 的目录结构（兼顾小型工具库、中型应用、大型框架的扩展性），参考了 Boost、muduo、fmt 等主流开源项目的设计思路，核心遵循「功能分离、层次清晰、跨平台兼容」原则： ``` ProjectName/ # 项目根目录（统一用项目名，无空格/特殊字符） ├── .github/ # GitHub 配置（可选，开源项目常用） │ ├── ISSUE_TEMPLATE/ # Issue 模板（bug 报告、功能请求等） │ ├── workflows/ # CI/CD 流水线配置（如 GitHub Actions） │ └── CONTRIBUTING.md # 贡献指南（如何提交 PR、代码规范等） ├── cmake/ # CMake 辅助配置（跨平台/模块管理） │ ├── FindXXX.cmake # 第三方库查找脚本（如 FindPthread.cmake） │ ├── ProjectConfig.cmake # 项目配置导出（供外部工程引用） │ └── CompilerOptions.cmake # 编译选项统一管理（-std=c++17、-Wall 等） ├── docs/ # 文档目录（结构化文档，避免散文件） │ ├── api/ # API 文档（如 Doxygen 生成的 HTML） │ ├── examples/ # 示例代码文档（配合 examples/ 目录） │ ├── install.md # 安装指南（支持 Linux/Mac/Windows） │ └── README.md # 文档总入口（项目介绍、快速上手） ├── examples/ # 示例程序（演示核心功能，新手友好） │ ├── hello_world/ # 简单示例（单个功能点） │ │ ├── CMakeLists.txt │ │ └── main.cpp │ └── advanced_usage/ # 复杂示例（多模块组合） │ ├── CMakeLists.txt │ └── main.cpp ├── include/ # 公开头文件（对外暴露的 API，必须稳定） │ └── ProjectName/ # 命名空间目录（避免头文件命名冲突） │ ├── core/ # 核心模块头文件（如核心类、接口） │ │ ├── Context.h │ │ └── Engine.h │ ├── utils/ # 工具类头文件（如日志、配置） │ │ ├── Log.h │ │ └── Config.h │ └── ProjectName.h # 总头文件（一键引入所有公开 API） ├── src/ # 私有源文件（实现代码，不对外暴露） │ ├── core/ # 核心模块实现（与 include/ 目录结构对齐） │ │ ├── Context.cpp │ │ ├── Engine.cpp │ │ └── detail/ # 内部细节（不对外的辅助类/函数） │ │ └── EngineImpl.h │ ├── utils/ # 工具类实现（与 include/ 对齐） │ │ ├── Log.cpp │ │ └── Config.cpp │ └── main.cpp # 可执行程序入口（若为应用项目） ├── tests/ # 测试用例（单元测试/集成测试，保证稳定性） │ ├── unit/ # 单元测试（测试单个类/函数，如用 Google Test） │ │ ├── TestLog.cpp │ │ └── TestConfig.cpp │ ├── integration/ # 集成测试（测试模块间交互） │ │ └── TestEngineWorkflow.cpp │ └── CMakeLists.txt # 测试工程配置（链接 gtest、项目库） ├── third_party/ # 第三方依赖（避免让用户手动安装） │ ├── fmt/ # 嵌入式依赖（如轻量库，直接放源码） │ │ ├── include/ │ │ └── src/ │ └── libs/ # 预编译库（如 Windows 下的 .lib/.dll） │ ├── windows/ │ └── linux/ ├── tools/ # 辅助工具（构建/部署/代码检查） │ ├── code_format.sh # 代码格式化脚本（clang-format） │ ├── generate_docs.sh # 文档生成脚本（Doxygen） │ └── package.sh # 打包脚本（生成 .deb/.rpm 安装包） ├── .gitignore # Git 忽略规则（编译产物、IDE 配置、日志等） ├── .clang-format # 代码格式化配置（统一代码风格） ├── CMakeLists.txt # 根目录 CMake（工程入口，统筹所有模块） ├── LICENSE # 开源许可证（如 MIT、Apache-2.0，必须有） └── README.md # 项目总入口（GitHub 首页展示，简洁明了） ``` ### 核心设计原则（为什么这么划分？） #### 1. 「公开 API + 私有实现」分离（`include/` vs `src/`） - `include/`：仅放对外暴露的头文件（API），必须保证稳定性（一旦发布不轻易修改函数签名、类结构）；目录下加「项目名命名空间」（如 `include/ProjectName/`），避免与其他库的头文件冲突（比如 `Log.h` 可能重名，`ProjectName/Log.h` 唯一）。 - `src/`：放 `.cpp` 实现文件和内部头文件（`detail/` 目录），内部结构与 `include/` 对齐（如 `src/core/` 对应 `include/ProjectName/core/`），方便查找。 #### 2. 「功能模块」按职责划分（而非文件类型） - 拒绝按「文件类型」划分（如 `src/cpp/`、`src/hpp/`），而是按「功能模块」划分（`core/`、`utils/`、`net/`），符合「高内聚低耦合」原则。 - 每个模块下的 `detail/` 目录放内部实现细节（如 `EngineImpl.h`），对外隐藏复杂逻辑，简化 API 接口。 #### 3. 「辅助目录」统一管理（避免根目录杂乱） - `cmake/`：集中管理 CMake 配置，避免根目录 `CMakeLists.txt` 过于庞大，同时方便跨平台适配（如 Windows 下的特殊编译选项）。 - `docs/` + `examples/`：降低使用门槛，`examples/` 提供可运行的代码，`docs/` 提供详细说明，新手能快速上手。 - `tests/`：保证代码质量，单元测试覆盖核心逻辑，集成测试覆盖关键流程，开源项目建议达到 70%+ 覆盖率。 #### 4. 「跨平台/开源友好」设计 - 支持 Linux/Mac/Windows：通过 `cmake/` 目录的脚本统一处理不同系统的编译差异，`third_party/` 放嵌入式依赖（避免用户手动安装）。 - 开源协作友好：`.github/` 目录提供贡献指南、CI 配置，`.clang-format` 统一代码风格，降低 PR 审核成本。 ### 不同规模项目的适配调整 #### 1. 小型工具库（如单文件工具、轻量组件） - 简化目录：移除 `examples/`、`tests/`、`third_party/`（若无依赖），保留核心目录： ``` ProjectName/ ├── include/ │ └── ProjectName/ │ └── Tool.h ├── src/ │ └── Tool.cpp ├── CMakeLists.txt ├── LICENSE └── README.md ``` #### 2. 中型应用（如服务端程序、桌面应用） - 强化 `src/` 目录的模块划分，增加 `net/`（网络）、`storage/`（存储）等模块，保留 `examples/`（演示部署）和 `tests/`（保证稳定性）。 #### 3. 大型框架（如分布式框架、SDK） - 增加 `modules/` 目录（拆分独立模块，支持按需编译），`deploy/` 目录（部署脚本、Docker 配置），`benchmarks/` 目录（性能测试）。 ### 必选文件（开源项目不能少） 1. `README.md`：项目介绍、快速安装、简单示例、联系方式（核心入口）； 2. `LICENSE`：开源许可证（无许可证可能被视为闭源，推荐 MIT/Apache-2.0）； 3. `CMakeLists.txt`：跨平台构建入口（避免用 Makefile 仅限 Linux）； 4. `.gitignore`：忽略编译产物（`build/`、`.exe`）、IDE 配置（`.idea/`、`*.sln`）、日志文件等。 ### 示例：根目录 `CMakeLists.txt` 简化模板（适配该结构） ```cmake cmake_minimum_required(VERSION 3.15) project(ProjectName VERSION 1.0.0 LANGUAGES CXX) # 统一编译选项（引入 cmake/ 目录的配置） include(cmake/CompilerOptions.cmake) # 公开头文件目录（让编译器找到 include/） include_directories(include) # 收集源文件（递归 src/ 目录） file(GLOB_RECURSE SRC_FILES CONFIGURE_DEPENDS "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp" "${CMAKE_CURRENT_SOURCE_DIR}/src/*.cc" ) # 生成库文件（静态库/动态库） add_library(${PROJECT_NAME} SHARED ${SRC_FILES}) # 动态库必需：位置无关代码 set_target_properties(${PROJECT_NAME} PROPERTIES POSITION_INDEPENDENT_CODE ON) # 链接第三方依赖（如 pthread、fmt） target_link_libraries(${PROJECT_NAME} pthread third_party::fmt) # 编译示例程序（可选，默认关闭，通过 -DBUILD_EXAMPLES=ON 开启） option(BUILD_EXAMPLES "Build examples" OFF) if(BUILD_EXAMPLES) add_subdirectory(examples) endif() # 编译测试用例（可选，默认关闭，通过 -DBUILD_TESTS=ON 开启） option(BUILD_TESTS "Build tests" OFF) if(BUILD_TESTS) add_subdirectory(tests) endif() # 安装配置（可选，make install 安装到系统目录） include(cmake/ProjectConfig.cmake) ``` ### 总结 该目录结构的核心优势是「**通用性强、扩展性好、降低协作成本**」： - 新手能快速找到「文档（docs/）」和「示例（examples/）」，快速上手； - 开发者能按「模块」维护代码，避免文件杂乱； - 外部工程能通过 CMake 快速引用（`find_package(ProjectName)`）； - 开源协作时，统一的结构和规范能减少沟通成本。 几乎所有主流 C++ 开源项目（如 fmt、spdlog、muduo）都遵循类似思路，只是根据项目规模略有简化或扩展，直接套用不会出错～