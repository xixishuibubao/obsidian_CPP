做高性能Linux应用开发，需要掌握的命令主要围绕**系统监控、性能分析、调试调优、资源管理、内核/底层信息查询**五大核心场景，这些命令能帮助你定位性能瓶颈、排查故障、优化程序效率。以下按**使用场景分类**，列出必须熟练掌握的命令及核心用法： 
### 一、系统监控与状态查询：
掌握系统整体运行情况 这类命令用于快速了解系统资源（CPU、内存、磁盘、网络）的使用状态，是性能分析的基础。
| 命令 | 核心用途 | 关键选项/用法示例 | |---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------| | `top`/`htop` | 实时监控进程的CPU、内存占用（`htop`是`top`的增强版，需安装）| `top -p <PID>`（监控指定进程）、`htop -u <用户>`（监控指定用户进程）| | `vmstat` | 查看系统整体的虚拟内存、进程、CPU活动（适合长期监控）| `vmstat 1 10`（每秒输出1次，共10次）、`vmstat -s`（显示内存统计信息）| | `mpstat` | 查看单个CPU/所有CPU的负载（定位CPU核数不均问题）| `mpstat -P ALL 1`（实时显示每个CPU的使用率）| | `iostat` | 监控磁盘I/O性能（定位磁盘瓶颈）| `iostat -d -x 1`（显示磁盘IO详细统计，每秒刷新）| | `sar` | 系统活动报告（支持CPU、内存、磁盘、网络的历史/实时统计，极其强大）| `sar -u 1 10`（CPU使用率）、`sar -b 1 10`（磁盘IO）、`sar -n DEV 1 10`（网络流量）| | `nmon` | 一站式系统监控工具（CPU、内存、磁盘、网络可视化，需安装）| 直接运行`nmon`，按对应键切换监控项（`c`=CPU，`m`=内存，`d`=磁盘）| | `free` | 查看内存使用情况（快速判断内存是否不足）| `free -h`（人类可读单位）、`free -s 1`（实时刷新）| | `df`/`du` | 磁盘空间查询（`df`看挂载点，`du`看文件/目录大小）| `df -h`、`du -sh <目录>`（统计目录总大小）、`du -h --max-depth=1`（按层级显示）| 
### 二、性能分析与调优：
定位程序性能瓶颈 这类命令是**高性能开发的核心**，用于深入分析程序的CPU、内存、IO、网络等瓶颈，包括硬件计数器、系统调用、函数调用等底层信息。 
#### 1. Perf工具链（Linux原生性能分析神器，必须精通） 
`perf`是Linux内核自带的性能分析工具，基于硬件计数器和内核跟踪点，能分析程序的CPU指令、缓存、函数调用、系统调用等，是定位CPU/微架构瓶颈的首选。
| 子命令 | 核心用途 | 示例 |
|----------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `perf stat` | 统计程序的性能事件（周期、指令、缓存命中/缺失等）| `perf stat -e cycles,instructions,cache-misses ./app`（统计关键事件）| | `perf top` | 实时显示程序中占用CPU最多的函数（定位CPU热点函数）| `perf top -p <PID>`（监控指定进程的热点函数）| | `perf record` | 记录程序的性能数据，后续用`perf report`分析 | `perf record -g -p <PID>`（记录调用栈，-g开启调用图）| | `perf report` | 分析`perf record`生成的日志，查看热点函数和调用栈 | 直接运行`perf report`，交互式查看结果 | | `perf list` | 列出系统支持的所有性能事件（硬件事件、软件事件、跟踪点）| `perf list hardware`（查看硬件事件）|
#### 2. 内存/堆分析命令
| 命令 | 核心用途 | 示例 | |---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `valgrind` | 内存调试神器（检测内存泄漏、越界访问、双重释放等，必须掌握）| `valgrind --leak-check=full ./app`（检测内存泄漏）、`valgrind --tool=cachegrind ./app`（分析缓存使用）| | `massif` | `valgrind`的子工具，分析程序的堆内存使用（定位内存峰值）| `valgrind --tool=massif ./app`，用`ms_print`查看结果 | | `pmap` | 查看进程的内存映射（了解程序的内存分布，如堆、栈、共享库）| `pmap -x <PID>`（详细内存映射）| | `malloc_stats`| 查看glibc的内存分配统计（需程序中调用，或用`gdb`触发）| 在`gdb`中执行`call malloc_stats()` | 
#### 3. 网络性能分析
| 命令 | 核心用途 | 示例 | |---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `iftop` | 实时监控网络流量（按连接/端口显示，需安装）| `iftop -i eth0`（监控指定网卡）| | `tcpdump` | 网络抓包神器（分析TCP/IP协议细节，定位网络延迟/丢包）| `tcpdump -i eth0 port 8080 -w capture.pcap`（抓包保存到文件）| | `wireshark` | 图形化抓包分析（配合`tcpdump`使用，`tshark`是命令行版）| `tshark -r capture.pcap`（命令行分析抓包文件）| | `ss` | 查看套接字统计（替代老旧的`netstat`，速度更快）| `ss -tulnp`（查看TCP/UDP端口占用）、`ss -s`（统计套接字状态）| | `nc`/`telnet` | 测试网络连接（验证端口是否可达）| `nc -zv <IP> <端口>`（测试端口连通性）| ### 三、调试与故障排查：解决程序崩溃/异常 高性能应用开发中，程序的崩溃、死锁、挂起等问题需要快速定位，这类命令是调试的核心。 | 命令 | 核心用途 | 关键用法示例 | |---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `gdb` | GNU调试器（调试程序崩溃、断点调试、查看调用栈，必须精通）| `gdb ./app`（启动调试）、`gdb -p <PID>`（附加到运行中的进程）、`bt`（查看调用栈）| | `strace` | 跟踪程序的系统调用和信号（定位系统调用失败、IO阻塞问题）| `strace -tt -p <PID>`（实时跟踪系统调用，显示时间戳）、`strace -c ./app`（统计系统调用次数）| | `ltrace` | 跟踪程序的库函数调用（补充`strace`，定位库函数问题）| `ltrace -p <PID>`（跟踪库函数调用）| | `pstack` | 打印进程的调用栈（快速定位死锁/挂起的原因）| `pstack <PID>`（需安装`util-linux`包）| | `gcore` | 生成进程的核心转储文件（离线分析崩溃问题）| `gcore <PID>`（生成core文件，用`gdb`分析）| | `dmesg` | 查看内核日志（定位内核级错误，如OOM、硬件驱动问题）| `dmesg -T`（显示时间戳）、`dmesg | grep -i oom`（查找OOM杀死进程的日志）| 
### 四、内核/底层信息查询：
了解系统底层配置 高性能开发需要深入了解内核参数、硬件特性、系统限制，这类命令能帮助你获取底层信息。 
| 命令 | 核心用途 | 示例 | |---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `lscpu` | 查看CPU硬件信息（架构、核心数、缓存、指令集等）| 直接运行`lscpu` | | `lsmem`/`lsblk` | 查看内存/磁盘硬件信息 | `lsmem`、`lsblk -f`（显示磁盘文件系统）| | `sysctl` | 查看/修改内核参数（如网络缓冲区、文件描述符限制、内存管理）| `sysctl -a`（查看所有内核参数）、`sysctl net.core.somaxconn`（查看TCP监听队列大小）| | `ulimit` | 查看/修改进程的资源限制（如最大文件描述符、最大线程数）| `ulimit -n`（查看最大文件描述符）、`ulimit -n 65535`（临时修改）| | `cat /proc/` | 查看内核实时状态（`/proc`是虚拟文件系统，包含进程、内存、CPU等信息）| `cat /proc/cpuinfo`（CPU详细信息）、`cat /proc/meminfo`（内存详细信息）、`cat /proc/<PID>/status`（进程状态）| | `modinfo`/`lsmod` | 查看内核模块信息（了解驱动/模块的配置）| `lsmod`（列出已加载模块）、`modinfo nvme`（查看NVMe驱动信息）| 
### 五、资源管理与系统调优：
优化系统资源分配 高性能应用往往需要调整系统资源限制、内核参数，这类命令用于配置系统级优化。 
| 命令 | 核心用途 | 示例 | 
|---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| | `taskset` | 绑定进程到指定CPU核心（避免进程在核心间切换，提升缓存命中率）| `taskset -c 0-3 ./app`（绑定进程到0-3核心）、`taskset -p <核心掩码> <PID>`（修改运行中的进程）| | `nice`/`renice` | 调整进程的优先级（让关键进程获得更多CPU时间）| `nice -n -20 ./app`（启动进程并设置高优先级）、`renice -n -20 <PID>`（修改运行中的进程优先级）| | `cgroup`/`systemd-cgtop` | 控制组管理（限制进程的CPU、内存、磁盘IO资源）| `systemd-cgtop`（监控cgroup资源使用）| | `ionice` | 调整进程的IO优先级（避免进程占用过多磁盘IO）| `ionice -c 1 -n 0 ./app`（设置实时IO优先级）| 
### 六、必备辅助命令：
提升开发效率 这类命令虽不直接用于性能分析，但能大幅提升日常开发和问题排查的效率。 
| 命令 | 核心用途 | 常用示例 | 
|---------------|--------------------------------------------------------------------------|----------------------------------------------------------------------| 
| `grep`/`awk`/`sed` | 文本处理（分析日志、提取关键信息）| `grep -i error app.log`（查找错误日志）、`awk '{print $1}'`（提取第一列）| 
| `sort`/`uniq` | 排序和去重（统计日志中的重复项）| `sort app.log | uniq -c`（统计每行出现的次数）|
| `tmux`/`screen` | 终端复用（保持后台会话，避免远程连接断开）| `tmux new -s session1`（创建会话）、`tmux attach -t session1`（连接会话）| 
| `rsync` | 高效文件同步（传输调试文件、日志）| `rsync -avz local.file user@remote:/path`（同步文件到远程）| 
### 七、学习优先级与实践建议 
1. **优先掌握核心工具**：`perf`、`gdb`、`strace`、`top`/`htop`、`vmstat`/`iostat`是基础，必须熟练使用。 
2. **结合实际场景练习**：比如用`perf stat`分析自己写的程序的CPU效率，用`valgrind`检测内存泄漏，用`tcpdump`分析网络延迟。 
3. **深入理解底层原理**：命令只是工具，要结合Linux内核的进程调度、内存管理、IO模型等知识，才能真正定位和解决性能问题。 
4. **熟悉自动化脚本**：将常用的监控/分析命令写成脚本（如批量统计进程CPU、自动抓包），提升效率。 ### 总结 高性能Linux应用开发的命令体系，核心是**“监控→分析→调试→调优”**的闭环：用监控命令发现问题，用性能分析命令定位瓶颈，用调试命令解决故障，用调优命令优化资源分配。掌握这些命令，并结合内核和硬件的底层知识，才能开发出高效、稳定的Linux应用。