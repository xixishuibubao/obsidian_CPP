## 1.优化缓存命中

- <1>对类/结构体等使用attribute((aligned(64)));或C++11引入的对齐关键字alignas(64)
    

1. 进行对齐，这是为了使得每个核心数据结构独立在缓存行，提高缓存命中，一般选64
    

2. 譬如
    

3. struct attribute((aligned(16))) MyStruct {DATA;};
    

- <2>嵌套循环尽量将大循环放在内部。
    

## 2.优化分支预测

- <1>逻辑运算转数学运算，
    

if(x>0){func1();} else{func2();}

优化为 (x>0)? func1():func2();

- <2>分支顺序优化
    

将大概率的分支放在前面，适用于if else和switch;

  热点数据问题，高概率分支优先处理，放在函数的前半部；

  高概率if放前面有利于分支预测。

```Markdown
注：同一个枚举在不同函数的switch case中，根据枚举的分布类型和冷热频率
    调整case顺序有利于分支预测。

<1>连续密集型： 123456,底层是跳表 case顺序基本无影响，但是热分支在前有轻微优化。
<2>离散型：1248，离散型底层是线性搜索，热分支在前有利于预测，较为明显的性能优化。
<3>混合型：为了兼容可读性和性能，连续区用枚举顺序，离散区使用热分支前置策略。
```

- <3>查表代替运算和逻辑判断,如果输入输出有固定映射，转为查表性能更优。
    

譬如最常见的CRC查表以及使用函数指针数组跳转的状态机机制

  

## 3.优化运行效率

- <1>有序比无序好命中，对于二分查找之类的操作，先排序是一个好主意。
    
- <2>分治思想，大块化小，最后归并。
    
- <3>合适的容器很重要，复杂度并不代表实际效率，还和数据量有关。
    
- <4> if 上移，尽可能在函数初期就判断条件，避免多次判断。
    
- <5> if 上移配合for批处理，尽可能if包裹for，而不是for包裹if，这样可以减少判断次数。
    

  

## 4.内存优化效率

- <1>使用栈内存比使用堆内存更快，不要滥用智能指针。
    
- <2>预分配内存，容器先预分配合适的大小，避免填充的时候扩容。
    
- <3>内存池技术，使用对象/内存池，避免频繁的从堆去分配内存。
    

  

## 5.流水线与CPU效率

ARM单片机采用多级流水线机制，可以加快访问效率，但是一旦遇到跳转操作就会丢弃剩余指令，因此减少跳转是优化的关键。

通过LR寄存器返回时，是返回的原PC+4的地址，是指示的程序下一行。