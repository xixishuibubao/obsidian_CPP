## 1. 缓存问题
1. 对类/结构体使用关键字进行对齐，以优化缓存行命中。
	- `attribute((aligned(64)))`;或`alignas(64)`，为了使每个核心数据结构独立在缓存行，***提高缓存命中***，一般选`64`。
	- `struct attribute((aligned(16))) MyStruct {DATA;};`
2. 嵌套循环尽量将大循环放在内部,***避免重复加载***缓存行。
    

## 2. 分支预测
1. 逻辑运算转数学运算:
	- ```c++
		if(x > 0) {
			func1( );
		} else {
			func2( );
		}
		/* 优化后 */
		(x > 0) ? func1( ) : func2( );
	  ```

2. 分支顺序优化(***冷热数据***)：
	- 将大概率的分支放在前面，适用于`if else`和`switch`。
	- ***热点数据***问题，***高概率***分支优先处理，放在函数的前半部。
	- ***高概率***`if`放前面有利于分支预测。

---
 - 注：同一个枚举`case`在不同函数的`switch case`中，根据枚举的分布类型和***冷热频率***调整`case`顺序有利于分支预测。

	1. 连续密集型: 123456,底层是跳表,`case`顺序基本无影响，但是热分支在前有***轻微***优化。
	2. 离散型: 1248，***离散型***底层是***线性搜索***，热分支在前有利于预测，较为***明显***的性能优化。
	3. 混合型：为了兼容可读性和性能，***连续区***用枚举***顺序***，***离散区***使用***热分支前置策略***。

3. ***查表***代替***运算和逻辑判断***:
	- 输入输出有固定映射时，查表性能更优。
		- 譬如CRC查表以及使用函数指针数组跳转的状态机机制。

  
## 3. 优化运行效率

1. ***有序***比***无序***好命中，对于二分查找之类的操作，***先排序***是一个好主意。   
2. ***分治***思想，大块化小，最后归并。
3. 合适的容器很重要，复杂度并不代表实际效率，还和数据量有关。
4. `if`上移，尽可能在函数初期就判断条件，***避免多次判断***。 
5. `if`上移配合`for`批处理，尽可能`if`包裹`for`，而不是`for`包裹`if`，***减少判断次数***。

## 4. 内存优化效率

1. ***栈内存***比***堆内存***更快，不要滥用智能指针。
2. ***预分配内存***，容器先预分配合适的大小，***避免填充时的多次扩容***。
3. ***内存池***，使用对象/内存池，避免***频繁分配***内存。

## 5. 流水线与CPU效率

1. ARM单片机采用***多级流水线***，可以加快访问效率。
	- 但遇到***跳转***操作就会***丢弃剩余***指令，***减少跳转***是优化的关键。
2. 通过LR寄存器返回时，是返回的原PC+4的地址，是指示的程序下一行。

## 6. 排查性能瓶颈

1. 使用`perf`和`gdb`来找到***热点函数***，并根据其类型进行代码优化。