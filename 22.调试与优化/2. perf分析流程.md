# 1. `perf`
## 1.1 `stat`
- `sudo perf stat ./myexe`,先获取大概的时间占比，分析性能瓶颈方向。
- `sudo perf stat -e cache-misses,cache-references ./myexe`,查看缓存命中情况。
## 1.2 `record`采样
- `sudo perf record -g -T ./myfile`,采样信息到`perf.data`文件。
- `sudo perf record -p pidid -g -T `,采样已经运行的程序。
## 1.3 `report`报告
- `sudo perf report -g graph,显示的最低阈值 -T`,打开刚才的`perf.data`查看其调用情况。

# 2. 火焰图`FlameGraph`
## 2.1 下载
- `git clone --depth=1 --branch master https://github.com/brendangregg/FlameGraph.git`
- 对于工具类的git仓库使用浅克隆快速拉取。
## 2.2 使用
1. `sudo perf srcipt > perfdata1`,将`perf.data`转为可读的中间格式,linux不关心文件名的文件类型，只关注内部的文件头标记，所以名字不做限制。
2. `sudo ~/dev/FlameGraph/stackcollapse-perf.pl perfdata1 >perfdata2`,再次改变格式
3. `sudo ~/dev/FlameGraph/flamegraph.pl perfdata2 >perfdata3.svg`,生成svg图片，用浏览器打开即可查看。
4. 横轴代表占比，纵轴代表调用深度

# 3. `objcopy`
- `perf`调试的程序必须带有`-g`选项，`-g3`会携带更多调试信息。
- 但带调试信息的版本不适合部署到现场，因此需要分离信息表，需要的时候再连回去。
- 链接回去之后`perf`可以正常的观察到信息，否则`report`的时候会出现异常或函数名不显示。

1. `objcopy --only-keep-debug myexe myexe.debug`,保存调试信息表，源程序不变。
2. `objcopy --strip-all myexe`,直接在源程序剔除符号表。
3. `objcopy --add-gnu-debuglink=myexe.debug myexe`,建立调试符号文件和源程序的链接。

# 4. `nm`
- `nm`用于查看符号表信息
- `nm -C -S -l ./myexe | grep "funcname"`，该操作可以和`report`联合查找热点函数所在的文件
	- `-C`：反混淆C++函数名（关键）
	- `-S`：显示符号地址
	- `-l`：尝试显示行号（可选）

# 5. `addr2line`
- `addr2line -f -C -e ./myexe 获取到的函数地址`
	- `-f`：显示函数名
	- `-C`：反混淆，编译器会将编译后的函数名混淆，该选项是为了显示原名
	- `-e`：指定可执行文件，后跟第一步拿到的地址
# 6. `ldd`
- `ldd myexe`,查看我的程序依赖的库
- `ldd myso.so`,查看动态库的依赖库